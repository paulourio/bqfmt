/* Lexical part */

/* String and bytes literals */
string_literal: [_raw_string_prefix](_sqtext|_sq3text|_dqtext|_dq3text) ;
bytes_literal:  (_bytes_prefix|_raw_bytes_prefix)(_sqtext|_sq3text|_dqtext|_dq3text) ;

unterminated_string_literal:                    _sqtext_0|_dqtext_0 ;
unterminated_triple_quoted_string_literal:      _sq3text_0|_dq3text_0 ;
unterminated_raw_string_literal:                _raw_string_prefix(_sqtext_0|_dqtext_0) ;
unterminated_triple_quoted_raw_string_literal:  _raw_string_prefix(_sq3text_0|_dq3text_0) ;
unterminated_bytes_literal:                     _bytes_prefix(_sqtext_0|_dqtext_0) ;
unterminated_raw_bytes_literal:                 _raw_bytes_prefix(_sqtext_0|_dqtext_0) ;
unterminated_triple_quoted_bytes_literal:       _bytes_prefix(_sq3text_0|_dq3text_0) ;
unterminated_triple_quoted_raw_bytes_literal:   _raw_bytes_prefix(_sq3text_0|_dq3text_0) ;

/*
    The abbreviations here:
      sq = single quote
      dq = double quote
      bq = backtick quote
      3  = triple quote
      _0 = unterminated versions.  They are used to return better error
            messages for unterminated strings and bytes.

    Here we accept arbitrary escapes instead of trying to narrowing it
    down just the valid set.  The actual validation of the escapes, and
    of things like UTF-8 structure, is done in the parser.
 */
_sqtext:      _sqtext_0 _sq ;
_sqtext_0:    _sq{(_no_backslash_sq_newline|_any_escape)} ;
_dqtext:      _dqtext_0 _dq ;
_dqtext_0:    _dq{(_no_backslash_dq_newline|_any_escape)} ;
_sq3text:     _sq3text_0 _sq3 ;
_sq3text_0:   _sq3{[(_sq|(_sq _sq))](_no_backslash_sq|_any_escape)} ;
_dq3text:     _dq3text_0 _dq3 ;
_dq3text_0:   _dq3{[(_dq|(_dq _dq))](_no_backslash_dq|_any_escape)} ;

_any_escape:              '\\'(_ascii_char|'"'|'\''|'\\'|'\n'|'\r');
_raw_string_prefix:       ('r'|'R') ;
_raw_bytes_prefix:        (('r'|'R')('b'|'B')) | (('b'|'B')('r'|'R')) ;
_bytes_prefix:            ('b'|'B') ;
_no_backslash_sq_newline: _char|'"' ;
_no_backslash_dq_newline: _char|'\'' ;
_no_backslash_sq:         _char|_dq|'\n' ;
_no_backslash_dq:         _char|_sq|'\n' ;
_sq3:                     _sq _sq _sq ;
_dq3:                     _dq _dq _dq ;
_sq:                      '\'' ;
_dq:                      '"' ;

_char:              _ascii_char|_unicode_byte ;
_ascii_char:        '\x01'-'\x09' /* skip null (0x00) */
                  | '\x0B'-'\x21' /* skip line feed (0x0A) */
                  | '\x23'-'\x26' /* skip double quote (0x22) */
                  | '\x28'-'\x5B' /* skip single quote (0x27) */
                  | '\x5D'-'\x7F' /* skip backslash (0x5C) */
                  ;
_unicode_byte:    '\u0080'-'\uFFFC'|'\uFFFE'-'\U0010FFFF' ;

/* Integer literals */
integer_literal: (_decimal_literal|_hex_literal) ;

/* Floating-point literals */
floating_point_literal: _float_literal ;

_float_literal:     _decimals'.'[_decimals][_exponent]
                  | _decimals _exponent
                  | '.'_decimals[_exponent]
                  ;
_decimals:        _decimal_digit{_decimal_digit} ;
_exponent:        ('e'|'E')['+'|'-']_decimals ;
_decimal_literal: _decimal_digit{_decimal_digit} ;
_decimal_digit:   '0'-'9' ;
_hex_literal:     '0'('x'|'X')_hex_digit{_hex_digit} ;
_hex_digit:       _decimal_digit|'a'-'f'|'A'-'F' ;

missing_whitespace_int_and_alias: _decimal_literal('a'-'z'|'A'-'Z'|'_') ;
missing_whitespace_hex_and_alias: _hex_literal('g'-'z'|'G'-'Z'|'_') ;
missing_whitespace_float_and_alias: _float_literal('a'-'z'|'A'-'Z'|'_') ;

/* Boolean literals */
boolean_literal: ('f'|'F')('a'|'A')('l'|'L')('s'|'S')('e'|'E')
               | ('t'|'T')('r'|'R')('u'|'U')('e'|'E')
               ;

/* Case-insensitive words */
all:        ('a'|'A')('l'|'L')('l'|'L') ;
and:        ('a'|'A')('n'|'N')('d'|'D') ;
array:      ('a'|'A')('r'|'R')('r'|'R')('a'|'A')('y'|'Y') ;
as:         ('a'|'A')('s'|'S') ;
asc:        ('a'|'A')('s'|'S')('c'|'C') ;
at:         ('a'|'A')('t'|'T') ;
between:    ('b'|'B')('e'|'E')('t'|'T')('w'|'W')('e'|'E')('e'|'E')('n'|'N') ;
bigdecimal: ('b'|'B')('i'|'I')('g'|'G')('d'|'D')('e'|'E')('c'|'C')('i'|'I')('m'|'M')('a'|'A')('l'|'L') ;
bignumeric: ('b'|'B')('i'|'I')('g'|'G')('n'|'N')('u'|'U')('m'|'M')('e'|'E')('r'|'R')('i'|'I')('c'|'C') ;
by:         ('b'|'B')('y'|'Y') ;
case:       ('c'|'C')('a'|'A')('s'|'S')('e'|'E') ;
cast:       ('c'|'C')('a'|'A')('s'|'S')('t'|'T') ;
cross:      ('c'|'C')('r'|'R')('o'|'O')('s'|'S')('s'|'S') ;
current:    ('c'|'C')('u'|'U')('r'|'R')('r'|'R')('e'|'E')('n'|'N')('t'|'T') ;
date:       ('d'|'D')('a'|'A')('t'|'T')('e'|'E') ;
datetime:   ('d'|'D')('a'|'A')('t'|'T')('e'|'E')('t'|'T')('i'|'I')('m'|'M')('e'|'E') ;
decimal:    ('d'|'D')('e'|'E')('c'|'C')('i'|'I')('m'|'M')('a'|'A')('l'|'L') ;
desc:       ('d'|'D')('e'|'E')('s'|'S')('c'|'C') ;
distinct:   ('d'|'D')('i'|'I')('s'|'S')('t'|'T')('i'|'I')('n'|'N')('c'|'C')('t'|'T') ;
else:       ('e'|'E')('l'|'L')('s'|'S')('e'|'E') ;
end:        ('e'|'E')('n'|'N')('d'|'D') ;
except:     ('e'|'E')('x'|'X')('c'|'C')('e'|'E')('p'|'P')('t'|'T') ;
extract:    ('e'|'E')('x'|'X')('t'|'T')('r'|'R')('a'|'A')('c'|'C')('t'|'T') ;
first:      ('f'|'F')('i'|'I')('r'|'R')('s'|'S')('t'|'T') ;
following:  ('f'|'F')('o'|'O')('l'|'L')('l'|'L')('o'|'O')('w'|'W')('i'|'I')('n'|'N')('g'|'G') ;
format:     ('f'|'F')('o'|'O')('r'|'R')('m'|'M')('a'|'A')('t'|'T') ;
from:       ('f'|'F')('r'|'R')('o'|'O')('m'|'M') ;
full:       ('f'|'F')('u'|'U')('l'|'L')('l'|'L') ;
group:      ('g'|'G')('r'|'R')('o'|'O')('u'|'U')('p'|'P') ;
having:     ('h'|'H')('a'|'A')('v'|'V')('i'|'I')('n'|'N')('g'|'G') ;
ignore:     ('i'|'I')('g'|'G')('n'|'N')('o'|'O')('r'|'R')('e'|'E') ;
in:         ('i'|'I')('n'|'N') ;
inner:      ('i'|'I')('n'|'N')('n'|'N')('e'|'E')('r'|'R') ;
intersect:  ('i'|'I')('n'|'N')('t'|'T')('e'|'E')('r'|'R')('s'|'S')('e'|'E')('c'|'C')('t'|'T') ;
interval:   ('i'|'I')('n'|'N')('t'|'T')('e'|'E')('r'|'R')('v'|'V')('a'|'A')('l'|'L') ;
is:         ('i'|'I')('s'|'S') ;
join:       ('j'|'J')('o'|'O')('i'|'I')('n'|'N') ;
json:       ('j'|'J')('s'|'S')('o'|'O')('n'|'N') ;
last:       ('l'|'L')('a'|'A')('s'|'S')('t'|'T') ;
left:       ('l'|'L')('e'|'E')('f'|'F')('t'|'T') ;
like:       ('l'|'L')('i'|'I')('k'|'K')('e'|'E') ;
limit:      ('l'|'L')('i'|'I')('m'|'M')('i'|'I')('t'|'T') ;
not:        ('n'|'N')('o'|'O')('t'|'T') ;
null:       ('n'|'N')('u'|'U')('l'|'L')('l'|'L') ;
nulls:      ('n'|'N')('u'|'U')('l'|'L')('l'|'L')('s'|'S') ;
numeric:    ('n'|'N')('u'|'U')('m'|'M')('e'|'E')('r'|'R')('i'|'I')('c'|'C') ;
offset:     ('o'|'O')('f'|'F')('f'|'F')('s'|'S')('e'|'E')('t'|'T') ;
on:         ('o'|'O')('n'|'N') ;
or:         ('o'|'O')('r'|'R') ;
order:      ('o'|'O')('r'|'R')('d'|'D')('e'|'E')('r'|'R') ;
outer:      ('o'|'O')('u'|'U')('t'|'T')('e'|'E')('r'|'R') ;
over:       ('o'|'O')('v'|'V')('e'|'E')('r'|'R') ;
partition:  ('p'|'P')('a'|'A')('r'|'R')('t'|'T')('i'|'I')('t'|'T')('i'|'I')('o'|'O')('n'|'N') ;
percent:    ('p'|'P')('e'|'E')('r'|'R')('c'|'C')('e'|'E')('n'|'N')('t'|'T') ;
preceding:  ('p'|'P')('r'|'R')('e'|'E')('c'|'C')('e'|'E')('d'|'D')('i'|'I')('n'|'N')('g'|'G') ;
proto:      ('p'|'P')('r'|'R')('o'|'O')('t'|'T')('o'|'O') ;
qualify:    ('q'|'Q')('u'|'U')('a'|'A')('l'|'L')('i'|'I')('f'|'F')('y'|'Y') ;
range:      ('r'|'R')('a'|'A')('n'|'N')('g'|'G')('e'|'E') ;
repeatable: ('r'|'R')('e'|'E')('p'|'P')('e'|'E')('a'|'A')('t'|'T')('a'|'A')('b'|'B')('l'|'L')('e'|'E') ;
replace:    ('r'|'R')('e'|'E')('p'|'P')('l'|'L')('a'|'A')('c'|'C')('e'|'E') ;
respect:    ('r'|'R')('e'|'E')('s'|'S')('p'|'P')('e'|'E')('c'|'C')('t'|'T') ;
right:      ('r'|'R')('i'|'I')('g'|'G')('h'|'H')('t'|'T') ;
rollup:     ('r'|'R')('o'|'O')('l'|'L')('l'|'L')('u'|'U')('p'|'P') ;
row:        ('r'|'R')('o'|'O')('w'|'W') ;
rows:       ('r'|'R')('o'|'O')('w'|'W')('s'|'S') ;
safe_cast:  ('s'|'S')('a'|'A')('f'|'F')('e'|'E')'_'('c'|'C')('a'|'A')('s'|'S')('t'|'T') ;
select:     ('s'|'S')('e'|'E')('l'|'L')('e'|'E')('c'|'C')('t'|'T') ;
struct:     ('s'|'S')('t'|'T')('r'|'R')('u'|'U')('c'|'C')('t'|'T') ;
tablesample: ('t'|'T')('a'|'A')('b'|'B')('l'|'L')('e'|'E')('s'|'S')('a'|'A')('m'|'M')('p'|'P')('l'|'L')('e'|'E') ;
then:       ('t'|'T')('h'|'H')('e'|'E')('n'|'N') ;
time:       ('t'|'T')('i'|'I')('m'|'M')('e'|'E') ;
timestamp:  ('t'|'T')('i'|'I')('m'|'M')('e'|'E')('s'|'S')('t'|'T')('a'|'A')('m'|'M')('p'|'P') ;
to:         ('t'|'T')('o'|'O') ;
unbounded:  ('u'|'U')('n'|'N')('b'|'B')('o'|'O')('u'|'U')('n'|'N')('d'|'D')('e'|'E')('d'|'D') ;
union:      ('u'|'U')('n'|'N')('i'|'I')('o'|'O')('n'|'N') ;
unnest:     ('u'|'U')('n'|'N')('n'|'N')('e'|'E')('s'|'S')('t'|'T') ;
using:      ('u'|'U')('s'|'S')('i'|'I')('n'|'N')('g'|'G') ;
weight:     ('w'|'W')('e'|'E')('i'|'I')('g'|'G')('h'|'H')('t'|'T') ;
when:       ('w'|'W')('h'|'H')('e'|'E')('n'|'N') ;
where:      ('w'|'W')('h'|'H')('e'|'E')('r'|'R')('e'|'E') ;
window:     ('w'|'W')('i'|'I')('n'|'N')('d'|'D')('o'|'O')('w'|'W') ;
with:       ('w'|'W')('i'|'I')('t'|'T')('h'|'H') ;
zone:       ('z'|'Z')('o'|'O')('n'|'N')('e'|'E') ;

comment: '-''-'{_single_line_comment_char}['\n']
       | '#'{_single_line_comment_char}['\n']
       | _cs_comment
       ;

unterminated_comment: _cs_comment_begin ;

/* C-style comments using slash+star */
_cs_comment:        _cs_comment_begin'*'{'*'}'/' ;
_cs_comment_begin:  '/''*'{(.|'*')} ;

_single_line_comment_char:
      '\x01'-'\x09'         /* skip null (0x00) */
    | '\x0B'-'\x7F'         /* skip line feed (0x0A) */
    | '\u0080'-'\uFFFC'
    | '\uFFFE'-'\U0010FFFF' /* skip invalid code point (\uFFFD) */
    ;

identifier: _unquoted_identifier|_bqtext ;

unterminated_escaped_identifier: _bqtext_0;

_unquoted_identifier: _id_0{(_id_0|'0'-'9')} ;
_id_0:      'a'-'z'|'A'-'Z'|'_' ;
_bqtext_0:  _bq{(_id_char|_any_escape)} ;
_bqtext:    _bqtext_0 _bq ;
_bq:        '`' ;
_id_char:   '\x01'-'\x09' /* skip null (0x00) */
          | '\x0B'-'\x5B' /* skip line feed (0x0A) */
          | '\x5D'-'\x5F' /* skip backslash (0x5C) */
          | '\x61'-'\x7F' /* skip backtick (0x60) */
          ;

!whitespace: ' '|'\t'|'\n'|'\r'|'\u00a0' ;

illegal_character: . ;

/* Syntax part */

<<
import (
    "github.com/paulourio/bqfmt/zetasql/ast"
)
>>

StartMode:
     SQLStatement
    ;

SQLStatement:
      UnterminatedSQLStatement OptSemicolon
    ;

UnterminatedSQLStatement:
      SQLStatementBody
    ;

OptSemicolon:
      ";"
    | empty
    ;

SQLStatementBody:
      QueryStatement
    ;

QueryStatement:
      Query
      << ast.NewQueryStatement($0) >>
    ;

/* We don't use OptWithClause  for the firest statemet because it causes
   shift/reduce conflicts.
 */
Query:
      WithClause
      QueryPrimaryOrSetOperation
      OptOrderByClause
      OptLimitOffsetClause
      << ast.NewQuery($0, $1, $2, $3) >>
    | QueryPrimaryOrSetOperation
      OptOrderByClause
      OptLimitOffsetClause
      << ast.NewQuery(nil, $0, $1, $2) >>
    ;

QueryPrimaryOrSetOperation:
      QueryPrimary
    ;

QueryPrimary:
      Select
    | "(" Query ")"
      << SetQueryParenthesized($0, $1, $2) >>
    ;

Select:
      select
      OptAllOrDistinct
      OptSelectAsClause
      SelectList
      OptFromClause
      OptWhereClause
      OptGroupByClause
      OptHavingClause
      OptQualifyClause
      OptWindowClause
      << NewSelect($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) >>
    ;

SelectList:
      SelectListPrefix
    | SelectListPrefix ","
      << UpdateLoc($0, $1) >>
    ;

SelectListPrefix:
      SelectColumn
      << ast.NewSelectList($0) >>
    | SelectListPrefix "," SelectColumn
      << WithExtraChild($0, $2) >>
    ;

SelectColumn:
      Expression
      << ast.NewSelectColumn($0, nil) >>
    | Expression as Alias
      << NewSelectExprAsAlias($0, $1, $2) >>
    | Expression Alias
      << ast.NewSelectColumn($0, $1) >>
    | Expression ".*"
      << NewSelectDotStar($0, $1) >>
    | Expression ".*" StarModifiers
      << NewSelectDotStarWithModifiers($0, $1, $2) >>
    | "*"
      << NewSelectStar($0) >>
    | "*" StarModifiers
      << NewSelectStarWithModifiers($0, $1) >>
    ;

Alias:
      Identifier << ast.NewAlias($0) >>
    ;

StarModifiers:
      StarExceptList
      << ast.NewStarModifiers($0, nil) >>
    | StarModifiersWithReplacePrefix ")"
      << UpdateLoc($0, $1) >>
    ;

StarExceptList:
      StarExceptListPrefix ")"
      << UpdateLoc($0, $1) >>
    ;

StarExceptListPrefix:
      except "(" Identifier
      << NewStarExceptList($0, $2) >>
    | StarExceptListPrefix "," Identifier
      << WithExtraChild($0, $2) >>
    ;

StarModifiersWithReplacePrefix:
      StarExceptList replace "(" StarReplaceItem
      << NewStarModifiers($0, $1, $3) >>
    | replace "(" StarReplaceItem
      << NewStarModifiers(nil, $0, $2) >>
    | StarModifiersWithReplacePrefix "," StarReplaceItem
      << WithExtraChild($0, $2) >>
    ;

StarReplaceItem:
      Expression as Identifier
      << ast.NewStarReplaceItem($0, $2) >>
    ;

WithClause:
      with WithClauseEntry
      << NewWithClause($0, $1) >>
    | WithClause "," WithClauseEntry
      << WithExtraChild($0, $2) >>
    ;

WithClauseEntry:
      Identifier as "(" Query ")"
      << NewWithClauseEntry($0, $3, $4) >>
    ;


OptWhereClause:
      WhereClause
    | empty
    ;

WhereClause:
      where Expression
      << NewWhereClause($0, $1) >>
    ;

OptAllOrDistinct:
      all       << WrapWithLoc(AllKeyword, $0) >>
    | distinct  << WrapWithLoc(DistinctKeyword, $1) >>
    | empty     << NoAllOrDistinctKeyword, nil >>
    ;

OptSelectAsClause:
      as struct
      << NewSelectAs($0, $1) >>
    | as PathExpression
      << NewSelectAs($0, $1) >>
    | empty
    ;

OptFromClause:
      from FromClauseContents
      << NewFromClause($0, $1) >>
    | empty
    ;

FromClauseContents:
      TablePrimary
    | FromClauseContents "," TablePrimary
      << NewCommaJoin($0, $2, $1) >>
    | FromClauseContents JoinType join TablePrimary OptOnOrUsingClauseList
      << NewJoin($0, $3, $4, $1, $2) >>
    ;

OptGroupByClause:
      GroupByClause
    | empty
    ;

GroupByClause:
      GroupByClausePrefix
    ;

GroupByClausePrefix:
      group by GroupingItem
      << NewGroupBy($0, $2) >>
    | GroupByClausePrefix "," GroupingItem
      << WithExtraChild($0, $2) >>
    ;

GroupingItem:
      Expression
      << ast.NewGroupingItem($0, nil) >>
    | RollupList ")"
      <<
      func() (Attrib, error) {
          rollup, err := UpdateLoc($0, $1)
          if err != nil {
              return nil, err
          }

          return ast.NewGroupingItem(nil, rollup)
      }()
      >>
    ;

RollupList:
      rollup "(" Expression
      << NewRollup($0, $2) >>
    | RollupList "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptHavingClause:
      HavingClause
    | empty
    ;

HavingClause:
      having Expression
      << NewHavingClause($0, $1) >>
    ;

OptQualifyClause:
      QualifyClause
    | empty
    ;

QualifyClause:
      qualify Expression
      << NewQualify($0, $1) >>
    ;

OptWindowClause:
      WindowClausePrefix
    | empty
    ;

WindowClausePrefix:
      window WindowDefinition
      << NewWindowClause($0, $1) >>
    | WindowClausePrefix "," WindowSpecification
      << WithExtraChild($0, $2) >>
    ;

WindowDefinition:
      Identifier as WindowSpecification
      << ast.NewWindowDefinition($0, $2) >>
    ;

/* This is only used for parenthesized joins. Unparenthesized JOINs are
   directly covered in FromClauseContents. These rules are separate
   because the FROM clause also allows comma joins, while parenthesized
   joins do not.

   Not that if there are consecutive ON/USING clauses, then this Join
   tree must be processed by TransformExpression in the rule
   TablePrimary before the final AST is returned.
 */
Join:
      JoinInput JoinType join TablePrimary OptOnOrUsingClauseList
      << NewJoin($0, $3, $4, $1, $2) >>
    ;

JoinInput:
      Join
    | TablePrimary
    ;

TablePrimary:
      TablePathExpression
    | "(" Join ")" OptSampleClause
      << NewParenthesizedJoin($1, $3, $0, $2) >>
    | TableSubquery
    ;

TablePathExpression:
      TablePathExpressionBase
      OptPivotOrUnpivotClauseAndAlias
      OptWithOffsetAndAlias
      OptSampleClause
      << NewTablePathExpression($0, $1, $2, $3) >>
    ;

TablePathExpressionBase:
      UnnestExpression
    | MaybeDashedPathExpression
    ;

UnnestExpression:
      unnest "(" Expression ")"
      << NewUnnestExpression($0, $2, $3) >>
    | unnest "(" select
      <<
      NewSyntaxError($2,
          "The argument to UNNEST is an expression, not a query; to use a "+
          "query as an expression, the query must be wrapped with "+
          "additional parentheses to make it a scalar subquery expression")
      >>
    ;

TableSubquery:
      "(" Query ")" OptPivotOrUnpivotClauseAndAlias OptSampleClause
      << NewTableSubquery($0, $1, $2, $3, $4) >>
    ;

OptPivotOrUnpivotClauseAndAlias:
      as Alias
      << PivotUnpivotAliasWithAlias($0, $1) >>
    | Alias
      << &pivotOrUnpivotAndAlias{Alias: $0}, nil >>
    | empty
      << &pivotOrUnpivotAndAlias{}, nil >>
    ;

OptWithOffsetAndAlias:
      with offset OptAsAlias
      << NewWithOffset($0, $1, $2) >>
    | empty
    ;

OptAsAlias:
      OptAs Alias
      << UpdateLoc($1, $0) >>
    | empty
    ;

OptAs:
      as
    | empty
    ;

OptOrderByClause:
      OrderByClausePrefix
    | empty
    ;

OrderByClausePrefix:
      order by OrderingExpression
      << NewOrderBy($0, $2) >>
    | OrderByClausePrefix "," OrderingExpression
      << WithExtraChild($0, $2) >>
    ;

OrderingExpression:
      Expression OptAscOrDesc OptNullOrder
      << ast.NewOrderingExpression($0, $2, $1) >>
    ;

OptAscOrDesc:
      asc   << WrapWithLoc(ast.AscendingOrder, $0) >>
    | desc  << WrapWithLoc(ast.DescendingOrder, $0) >>
    | empty << ast.NoOrderingSpec, nil >>
    ;

OptNullOrder:
      nulls first
      << NewNullOrder($0, $1, true) >>
    | nulls last
      << NewNullOrder($0, $1, false) >>
    | empty
    ;

OptLimitOffsetClause:
      limit PossiblyCastIntLiteralOrParameter
      offset PossiblyCastIntLiteralOrParameter
      << NewLimitOffset($0, $1, $3) >>
    | limit PossiblyCastIntLiteralOrParameter
      << NewLimitOffset($0, $1, nil) >>
    | empty
    ;

WindowSpecification:
      Identifier
      << ast.NewWindowSpecification($0, nil, nil, nil) >>
    | "("
      OptIdentifier
      OptPartitionByClause
      OptOrderByClause
      OptWindowFrameClause
      ")"
      << NewWindowSpecification($0, $1, $2, $3, $4, $5) >>
    ;

OptIdentifier:
      Identifier
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      << NewPartitionBy($0, $2) >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptWindowFrameClause:
      FrameUnit between WindowFrameBound and WindowFrameBound
    | FrameUnit WindowFrameBound
    | empty
    ;

FrameUnit:
      rows   << WrapWithLoc(ast.Rows, $0) >>
    | range  << WrapWithLoc(ast.Range, $0) >>
    ;

WindowFrameBound:
      unbounded preceding
      << NewWindowFrameExprOnlyWithType($0, $1, ast.UnboundedPreceding) >>
    | unbounded following
      << NewWindowFrameExprOnlyWithType($0, $1, ast.UnboundedFollowing) >>
    | current row
      << NewWindowFrameExprOnlyWithType($0, $1, ast.CurrentRow) >>
    | Expression PrecedingOrFollowing
      << ast.NewWindowFrameExpr($0, $1) >>
    ;

PrecedingOrFollowing:
      preceding  << WrapWithLoc(ast.OffsetPreceding, $0) >>
    | following  << WrapWithLoc(ast.OffsetFollowing, $0) >>
    ;

IntervalExpression:
      interval Expression Identifier
      << NewIntervalExpression($0, $1, $2, nil) >>
    | interval Expression Identifier to Identifier
      << NewIntervalExpression($0, $1, $2, $4) >>
    ;

Type:
      RawType OptTypeParameters
      << NewNamedType($0, $1) >>
    ;

RawType:
      TypeName
    ;

TypeName:
      PathExpression
      << ast.NewNamedType($0) >>
    | ArrayType
    | StructType
    ;

ArrayType:
      array "<" Type ">"
      << NewArrayType($0, $2, $3) >>
    ;

StructType:
      struct "<" ">"
      << NewStructType($0, nil, $2) >>
    | StructTypePrefix ">"
      << UpdateLoc($0, $1) >>
    ;

StructTypePrefix:
      struct "<" StructField
      << NewStructType($0, $2, nil) >>
    | StructTypePrefix "," StructField
      << WithExtraChild($0, $2) >>
    ;

StructField:
      Identifier Type
      << ast.NewStructField($0, $1) >>
    | Type
      << ast.NewStructField(nil, $0) >>
    ;

/* Expressions are organized by precedence order. */
Expression:
      Expression12
    ;

/* Binary OR operator */
Expression12:
      Expression12 or Expression11
      << ast.NewOrExpr(List($0, $2)) >>
    | Expression11
    ;

/* Binary AND operator */
Expression11:
      Expression11 and Expression10
      << ast.NewAndExpr(List($0, $2)) >>
    | Expression10
    ;

/* Unary NOT operator */
Expression10:
      not Expression9
      << NewNotUnaryExpression($0, $1) >>
    | Expression9
    ;

/* Comparison operators: eq, lt, le, gt, ge, ne, like, is */
Expression9:
      Expression9 ComparativeOperator Expression8
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression9 LikeOperator Expression8
      << NewLikeBinaryExpression($1, $0, $2) >>
    | Expression9 InOperator Expression8
      << NewInBinaryExpression($1, $0, $2) >>
    | Expression9 BetweenOperator Expression8 and Expression8
      << NewBetweenExpression($0, $1, $2, $3, $4) >>
    | Expression9 IsOperator InExpressionRHS
      << NewIsBinaryExpression($1, $0, $2) >>
    | Expression8
    ;

InExpressionRHS:
      NullLiteral
    | BooleanLiteral
    ;

/* Bitwise OR operator */
Expression8:
      Expression8 "|" Expression7
      << ast.NewBinaryExpression(ast.BinaryBitwiseOr, $0, $2, false) >>
    | Expression7
    ;

/* Bitwise XOR operator */
Expression7:
      Expression7 "^" Expression6
      << ast.NewBinaryExpression(ast.BinaryBitwiseXor, $0, $2, false) >>
    | Expression6
    ;

/* Bitwise AND operator */
Expression6:
      Expression6 "&" Expression5
      << ast.NewBinaryExpression(ast.BinaryBitwiseAnd, $0, $2, false) >>
    | Expression5
    ;

/* Bitwise left and right shift operators. */
Expression5:
      Expression5 ShiftOperator Expression4
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression4
    ;

/* Addition and subtraction operators */
Expression4:
      Expression4 AdditiveOperator Expression3
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3
    ;

/* Multiplication, division, and concatenation operators. */
Expression3:
      Expression3 MultiplicativeOperator Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3 ConcatOp Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression2
    ;

/* Unary operators */
Expression2:
      UnaryOperator Expression2
      << ast.NewUnaryExpression($0, $1) >>
    | Expression1
    ;

/* Field access operator, array subscript operator */
Expression1:
      NullLiteral
    | IntegerLiteral
    | BooleanLiteral
    | BytesLiteral
    | StringLiteral
    | FloatingPointLiteral
    | NumericLiteral
    | BigNumericLiteral
    | DateOrTimeLiteral
    | JSONLiteral
    | ParenthesizedExpression
    | ArrayConstructor
    | StructConstructor
    | CaseExpression
    | CastExpression
    | FunctionCallExpressionWithClauses
    | Expression1 "[" Expression1 "]"
      << NewArrayElement($0, $1, $2, $3) >>
    | Expression1 "." Identifier
      << ExpandPathExpressionOrNewDotIdentifier($0, $1, $2) >>
    | IntervalExpression
    | Identifier
      << ast.NewPathExpression($0) >>
    ;

LikeOperator:
      like     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not like << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

InOperator:
      in      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not in  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

BetweenOperator:
      between     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not between << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

IsOperator:
      is      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | is not  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

UnaryOperator:
      "+"  << WrapWithLoc(ast.UnaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.UnaryMinus, $0) >>
    | "~"  << WrapWithLoc(ast.UnaryBitwiseNot, $0) >>
    ;

MultiplicativeOperator:
      "*"  << WrapWithLoc(ast.BinaryMultiply, $0) >>
    | "/"  << WrapWithLoc(ast.BinaryDivide, $0) >>
    ;

AdditiveOperator:
      "+"  << WrapWithLoc(ast.BinaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.BinaryMinus, $0) >>
    ;

ConcatOp:
      "||" << WrapWithLoc(ast.BinaryConcat, $0) >>
    ;

ShiftOperator:
      "<<"  << WrapWithLoc(ast.LeftShift, $0) >>
    | ">>"  << WrapWithLoc(ast.RightShift, $0) >>
    ;

IntegerLiteral:
      integer_literal
      << NewIntLiteral($0) >>
    ;

StringLiteral:
      string_literal
      << NewStringLiteral($0) >>
    ;

FloatingPointLiteral:
      floating_point_literal
      << NewFloatLiteral($0) >>
    ;

BytesLiteral:
      bytes_literal
      << NewBytesLiteral($0) >>
    ;

BooleanLiteral:
      boolean_literal
      << NewBooleanLiteral($0) >>
    ;

NullLiteral:
      null
      << NewNullLiteral($0) >>
    ;

NumericLiteral:
      NumericPrefix string_literal
      << NewNumericLiteral($0, $1) >>
    ;

NumericPrefix:
      numeric
    | decimal
    ;

BigNumericLiteral:
      BigNumericPrefix string_literal
      << NewBigNumericLiteral($0, $1) >>
    ;

BigNumericPrefix:
      bignumeric
    | bigdecimal
    ;

DateOrTimeLiteral:
      DateOrTimeLiteralKind StringLiteral
      << NewDateOrTimeLiteral($0, $1) >>
    ;

DateOrTimeLiteralKind:
      date       << WrapWithLoc(ast.DateKind, $0) >>
    | datetime   << WrapWithLoc(ast.DateTimeKind, $0) >>
    | time       << WrapWithLoc(ast.TimeKind, $0) >>
    | timestamp  << WrapWithLoc(ast.TimestampKind, $0) >>
    ;

JSONLiteral:
      json string_literal
      << NewJSONLiteral($0, $1) >>
    ;

MaybeDashedPathExpression:
      PathExpression
    | DashedPathExpression
    ;

PathExpression:
      Identifier
      << ast.NewPathExpression($0) >>
    | PathExpression "." Identifier
      << WithExtraChild($0, $2) >>
    ;

DashedPathExpression:
      DashedIdentifier
    | DashedPathExpression "." Identifier
    ;

DashedIdentifier:
      identifier "-" identifier
      << NewDashedIdentifier($0, $1) >>
    ;

Identifier:
      identifier
      << NewIdentifier($0, true) >>
    | KeywordAsIdentifier
      << NewIdentifier($0, true) >>
    ;

KeywordAsIdentifier:
      date
    | numeric
    | decimal
    | bignumeric
    | bigdecimal
    | extract
    | with
    | json
    ;

ParenthesizedExpression:
      "(" Expression ")"
      << SetExpressionParenthesized($0, $1, $2) >>
    ;

OptSampleClause:
      SampleClause
    | empty
    ;

SampleClause:
      tablesample Identifier "(" SampleSize ")" OptSampleClauseSuffix
      << NewSampleClause($0, $1, $3, $4, $5) >>
    ;

SampleSize:
      SampleSizeValue SampleSizeUnit OptPartitionByClause
      << ast.NewSampleSize($0, $1, $2) >>
    ;

SampleSizeValue:
      PossiblyCastIntLiteralOrParameter
    | FloatingPointLiteral
    ;

SampleSizeUnit:
      rows     << WrapWithLoc(ast.RowsSampling, $0) >>
    | percent  << WrapWithLoc(ast.PercentSampling, $0) >>
    ;

OptSampleClauseSuffix:
      RepeatableClause
      << NewSampleClauseSuffix(nil, nil, nil, $0) >>
    | with weight OptRepeatableClause
      << NewSampleClauseSuffix($0, nil, nil, $1) >>
    | with weight Alias OptRepeatableClause
      << NewSampleClauseSuffix($0, nil, $1, $2) >>
    | with weight as Alias OptRepeatableClause
      << NewSampleClauseSuffix($0, $1, $2, $3) >>
    | empty
    ;

OptRepeatableClause:
      RepeatableClause
    | empty
    ;

RepeatableClause:
      repeatable "(" PossiblyCastIntLiteralOrParameter ")"
      << NewRepeatableClause($0, $2, $3) >>
    ;

PossiblyCastIntLiteralOrParameter:
      CastIntLiteralOrParameter
    | IntLiteralOrParameter
    ;

CastIntLiteralOrParameter:
      cast "(" IntLiteralOrParameter as Type OptFormat ")"
      << NewCastIntLiteralOrParam($0, $2, $4, $5, $6) >>
    ;

IntLiteralOrParameter:
      IntegerLiteral
    | ParameterExpression
    ;

ParameterExpression:
      NamedParameterExpression
    ;

NamedParameterExpression:
      "@" Identifier
      << NewParameterExpr($0, $1) >>
    | "@" KeywordAsIdentifier
      << NewParameterExpr($0, $1) >>
    ;

OptFormat:
      format Expression OptAtTimeZone
      << NewFormatClause($0, $1, $2) >>
    | empty
    ;

OptAtTimeZone:
      at time zone Expression << $3, nil >>
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      <<
      func() (Attrib, error) {
          c, err := ast.NewPartitionBy($2)
          if err != nil { return nil, err }
          return UpdateLoc(c, $0)
      }()
      >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptTypeParameters:
      TypeParametersPrefix ")"
      << UpdateLoc($0, $1) >>
    | empty
    ;

TypeParametersPrefix:
      "(" TypeParameter
      <<
      func() (Attrib, error) {
          e, err := ast.NewTypeParameterList($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | TypeParametersPrefix "," TypeParameter
      << WithExtraChild($0, $2) >>
    ;

TypeParameter:
      IntegerLiteral
    | BooleanLiteral
    | StringLiteral
    | BytesLiteral
    | FloatingPointLiteral
    ;

OptOnOrUsingClauseList:
      OnOrUsingClauseList
    | empty
    ;

OnOrUsingClauseList:
      OnOrUsingClause
      << ast.NewOnOrUsingClauseList($0) >>
    | OptOnOrUsingClauseList OnOrUsingClause
      << WithExtraChild($0, $1) >>
    ;

OnOrUsingClause:
      OnClause
    | UsingClause
    ;

OnClause:
      on Expression
      <<
      func() (Attrib, error) {
          e, err := ast.NewOnClause($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    ;

UsingClause:
      UsingClausePrefix ")"
      << UpdateLoc($0, $1) >>
    ;

UsingClausePrefix:
      using "(" Identifier
      <<
      func() (Attrib, error) {
          c, err := ast.NewUsingClause($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | UsingClausePrefix "," Identifier
      << WithExtraChild($0, $2) >>
    ;

JoinType:
      cross           << WrapWithLoc(ast.CrossJoin, $0) >>
    | full OptOuter   << WrapWithLoc(ast.FullJoin, $0, $1) >>
    | inner           << WrapWithLoc(ast.InnerJoin, $0) >>
    | left OptOuter   << WrapWithLoc(ast.LeftJoin, $0, $1) >>
    | right OptOuter  << WrapWithLoc(ast.RightJoin, $0, $1) >>
    | empty           << ast.DefaultJoin, nil >>
    ;

OptOuter:
      outer
    | empty
    ;

FunctionCallExpressionWithClauses:
      FunctionCallExpression OptOverClause
      <<
      func() (Attrib, error) {
          if $1 != nil {
              return ast.NewAnalyticFunctionCall($0, $1)
          }

          return $0, nil
      }()
      >>
    ;

FunctionCallExpression:
      /* Empty argument list */
      FunctionCallExpressionBase
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      << NewFunctionCall($0, nil, $1, $2, $3) >>
      /* Non-empty argument list. */
    | FunctionCallExpressionWithArgsPrefix
      OptNullHandlingModifier
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      << NewFunctionCall($0, $1, $2, $3, $4) >>
    ;

FunctionCallExpressionWithArgsPrefix:
      FunctionCallExpressionBase FunctionCallArgument
      << WithExtraChild($0, $1) >>
    | FunctionCallExpressionBase "*"
      <<
      func() (Attrib, error) {
          s, err := ast.NewStar()
          if err != nil {
              return nil, err
          }

          s.SetImage("*")

          l, err := UpdateLoc(s, $1)
          if err != nil {
              return nil, err
          }

          return WithExtraChild($0, l)
      }()
      >>
    | FunctionCallExpressionWithArgsPrefix "," FunctionCallArgument
      << WithExtraChild($0, $2) >>
    ;

FunctionCallExpressionBase:
      Expression "(" distinct
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, true)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $2)
      }()
      >>
    | Expression "("
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, false)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $1)
      }()
      >>
    ;

FunctionCallArgument:
      Expression
    ;

OptNullHandlingModifier:
      ignore nulls
      << WrapWithLoc(ast.IgnoreNulls, $0, $1) >>
    | respect nulls
      << WrapWithLoc(ast.RespectNulls, $0, $1) >>
    | empty
      << ast.DefaultNullHandling, nil >>
    ;

OptOverClause:
      OverClause
    | empty
    ;

OverClause:
      over WindowSpecification
      << UpdateLoc($1, $0) >>
    ;

CastExpression:
      cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, false)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $6)
      }()
      >>
    | safe_cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, true)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $6)
      }()
      >>
    ;

ArrayConstructor:
      ArrayConstructorPrefixNoExpressions "]"
      << UpdateLoc($0, $1) >>
    | ArrayConstructorPrefix "]"
      << UpdateLoc($0, $1) >>
    ;

ArrayConstructorPrefixNoExpressions:
      array "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0, $1)
      }()
      >>
    | "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | ArrayType "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor($0)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $1)
      }()
      >>
    ;

ArrayConstructorPrefix:
      ArrayConstructorPrefixNoExpressions Expression
      << WithExtraChild($0, $1) >>
    | ArrayConstructorPrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructor:
      StructConstructorPrefix ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithKeywordNoArg ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithoutKeyword ")"
      << UpdateLoc($0, $1) >>
    ;

StructConstructorPrefix:
      StructConstructorPrefixWithKeyword
    | StructConstructorPrefixWithKeywordNoArg
    | StructConstructorPrefixWithoutKeyword
    ;

StructConstructorPrefixWithKeyword:
      StructConstructorPrefixWithKeywordNoArg StructConstructorArg
    ;

StructConstructorPrefixWithKeywordNoArg:
      StructType "("
      << ast.NewStructConstructorWithKeyword($0) >>
    | struct "("
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithKeyword(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    ;

StructConstructorPrefixWithoutKeyword:
      "(" Expression "," Expression
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithParens(List($1, $3))
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    | StructConstructorPrefixWithoutKeyword "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructorArg:
      Expression OptAsAliasWithRequiredAs
      << ast.NewStructConstructorArg($0, $1) >>
    ;

OptAsAliasWithRequiredAs:
      as Identifier
      <<
      func() (Attrib, error) {
          a, err := ast.NewAlias($1)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(a, $0)
      }()
      >>
    | empty
    ;

CaseExpression:
      CaseExpressionPrefix end
      << UpdateLoc($0, $1) >>
    | CaseExpressionPrefix else Expression end
      <<
      func() (Attrib, error) {
          e, err := WithExtraChild($0, $2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $3)
      }()
      >>
    ;

CaseExpressionPrefix:
      CaseNoValueExpressionPrefix
    | CaseValueExpressionPrefix
    ;

CaseValueExpressionPrefix:
      case Expression when Expression then Expression
      <<
      func() (Attrib, error) {
          e, err := ast.NewCaseValueExpression(List($1, $3, $5))
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | CaseValueExpressionPrefix when Expression then Expression
      << WithExtraChildren($0, $2, $4) >>
    ;

CaseNoValueExpressionPrefix:
      case when Expression then Expression
      <<
      func() (Attrib, error) {
          e, err := ast.NewCaseNoValueExpression(List($2, $4))
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | CaseNoValueExpressionPrefix when Expression then Expression
      << WithExtraChildren($0, $2, $4) >>
    ;

ComparativeOperator:
      "="   << WrapWithLoc(ast.BinaryEq, $0) >>
    | "!="  << WrapWithLoc(ast.BinaryNE, $0) >>
    | "<>"  << WrapWithLoc(ast.BinaryNE2, $0) >>
    | "<"   << WrapWithLoc(ast.BinaryLT, $0) >>
    | "<="  << WrapWithLoc(ast.BinaryLE, $0) >>
    | ">"   << WrapWithLoc(ast.BinaryGT, $0) >>
    | ">="  << WrapWithLoc(ast.BinaryGE, $0) >>
    ;
