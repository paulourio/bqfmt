/* Lexical part */

/* String and bytes literals */
string_literal:
      _triple_quoted_string
    | _quoted_string
    | _raw_string
    ;

bytes_literal:
      _bytes_prefix _triple_quoted_string
    | _bytes_prefix _quoted_string
    | _raw_bytes
    ;

/* Boolean literals */
boolean_literal:
      ( 'f' | 'F' ) ( 'a' | 'A' ) ( 'l' | 'L' ) ( 's' | 'S' ) ( 'e' | 'E' )
    | ( 't' | 'T' ) ( 'r' | 'R' ) ( 'u' | 'U' ) ( 'e' | 'E' )
    ;

/* Integer literals */
integer_literal:
      ( _decimal_literal | _hex_literal )
    ;

/* Floating-point literals */
floating_point_literal:
      _decimals '.' [ _decimals ] [ _exponent ]
    | _decimals _exponent
    | '.' _decimals [ _exponent ]
    ;

/* Date or time literals */
date:
      ( 'd' | 'D' ) ( 'a' | 'A' ) ( 't' | 'T' ) ( 'e' | 'E' )
    ;

datetime:
      ( 'd' | 'D' ) ( 'a' | 'A' ) ( 't' | 'T' ) ( 'e' | 'E' )
      ( 't' | 'T' ) ( 'i' | 'I' ) ( 'm' | 'M' ) ( 'e' | 'E' )
    ;

time:
      ( 't' | 'T' ) ( 'i' | 'I' ) ( 'm' | 'M' ) ( 'e' | 'E' )
    ;

timestamp:
      ( 't' | 'T' ) ( 'i' | 'I' ) ( 'm' | 'M' ) ( 'e' | 'E' )
      ( 's' | 'S' ) ( 't' | 'T' ) ( 'a' | 'A' ) ( 'm' | 'M' ) ( 'p' | 'P' )
    ;

/* Numeric and decimal prefixes */
numeric_or_decimal:
      ( 'n' | 'N' ) ( 'u' | 'U' ) ( 'm' | 'M' ) ( 'e' | 'E' )
      ( 'r' | 'R' ) ( 'i' | 'I' ) ( 'c' | 'C' )
    | ( 'd' | 'D' ) ( 'e' | 'E' ) ( 'c' | 'C' ) ( 'i' | 'I' )
      ( 'm' | 'M' ) ( 'a' | 'A' ) ( 'l' | 'L' )
    ;

bignumeric_or_bigdecimal:
      ( 'b' | 'B' ) ( 'i' | 'I' ) ( 'g' | 'G' ) ( 'n' | 'N' ) ( 'u' | 'U' )
      ( 'm' | 'M' ) ( 'e' | 'E' ) ( 'r' | 'R' ) ( 'i' | 'I' ) ( 'c' | 'C' )
    | ( 'b' | 'B' ) ( 'i' | 'I' ) ( 'g' | 'G' ) ( 'd' | 'D' ) ( 'e' | 'E' )
      ( 'c' | 'C' ) ( 'i' | 'I' ) ( 'm' | 'M' ) ( 'a' | 'A' ) ( 'l' | 'L' )
    ;

/* Array and struct literals prefix */
array:
      ( 'a' | 'A' ) ( 'r' | 'R' ) ( 'r' | 'R' ) ( 'a' | 'A' ) ( 'y' | 'Y' )
    ;

struct:
      ( 's' | 'S' ) ( 't' | 'T' ) ( 'r' | 'R' ) ( 'u' | 'U' )
      ( 'c' | 'C' ) ( 't' | 'T' )
    ;

/* Case-insensitive words */
null:
      ( 'n' | 'N' ) ( 'u' | 'U' ) ( 'l' | 'L' ) ( 'l' | 'L' )
    ;

format:
      ( 'f' | 'F' ) ( 'o' | 'O' ) ( 'r' | 'R' )
      ( 'm' | 'M' ) ( 'a' | 'A' ) ( 't' | 'T' )
    ;

select:
      ( 's' | 'S' ) ( 'e' | 'E' ) ( 'l' | 'L' ) ( 'e' | 'E' )
      ( 'c' | 'C' ) ( 't' | 'T' )
    ;

from:
      ( 'f' | 'F' ) ( 'r' | 'R' ) ( 'o' | 'O' ) ( 'm' | 'M' )
    ;

with:
      ( 'w' | 'W' ) ( 'i' | 'I' ) ( 't' | 'T' ) ( 'h' | 'H' )
    ;

as:
      ( 'a' | 'A' ) ( 's' | 'S' )
    ;

to:
      ( 't' | 'T' ) ( 'o' | 'O' )
    ;

and:
      ( 'a' | 'A' ) ( 'n' | 'N' ) ( 'd' | 'D' )
    ;

or:
      ( 'o' | 'O' ) ( 'r' | 'R' )
    ;

is:
      ( 'i' | 'I' ) ( 's' | 'S' )
    ;

in:
      ( 'i' | 'I' ) ( 'n' | 'N' )
    ;

intersect:
      ( 'i' | 'I' ) ( 'n' | 'N' ) ( 't' | 'T' ) ( 'e' | 'E' ) ( 'r' | 'R' )
      ( 's' | 'S' ) ( 'e' | 'E' ) ( 'c' | 'C' ) ( 't' | 'T' )
    ;

union:
      ( 'u' | 'U' ) ( 'n' | 'N' ) ( 'i' | 'I' ) ( 'o' | 'O' ) ( 'n' | 'N' )
    ;

like:
      ( 'l' | 'L' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'e' | 'E' )
    ;

not:
      ( 'n' | 'N' ) ( 'o' | 'O' ) ( 't' | 'T' )
    ;

row:
      ( 'r' | 'R' ) ( 'o' | 'O' ) ( 'w' | 'W' )
    ;

rows:
      ( 'r' | 'R' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 's' | 'S' )
    ;

range:
      ( 'r' | 'R' ) ( 'a' | 'A' ) ( 'n' | 'N' ) ( 'g' | 'G' ) ( 'e' | 'E' )
    ;

following:
      ( 'f' | 'F' ) ( 'o' | 'O' ) ( 'l' | 'L' ) ( 'l' | 'L' )
      ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'n' | 'N' )
      ( 'g' | 'G' )
    ;

preceding:
      ( 'p' | 'P' ) ( 'r' | 'R' ) ( 'e' | 'E' ) ( 'c' | 'C' )
      ( 'e' | 'E' ) ( 'd' | 'D' ) ( 'i' | 'I' ) ( 'n' | 'N' )
      ( 'g' | 'G' )
    ;

current:
      ( 'c' | 'C' ) ( 'u' | 'U' ) ( 'r' | 'R' ) ( 'r' | 'R' )
      ( 'e' | 'E' ) ( 'n' | 'N' ) ( 't' | 'T' )
    ;

partition:
      ( 'p' | 'P' ) ( 'a' | 'A' ) ( 'r' | 'R' ) ( 't' | 'T' ) ( 'i' | 'I' )
      ( 't' | 'T' ) ( 'i' | 'I' ) ( 'o' | 'O' ) ( 'n' | 'N' )
    ;

between:
      ( 'b' | 'B' ) ( 'e' | 'E' ) ( 't' | 'T' ) ( 'w' | 'W' )
      ( 'e' | 'E' ) ( 'e' | 'E' ) ( 'n' | 'N' )
    ;

respect:
      ( 'r' | 'R' ) ( 'e' | 'E' ) ( 's' | 'S' ) ( 'p' | 'P' )
      ( 'e' | 'E' ) ( 'c' | 'C' ) ( 't' | 'T' )
    ;

ignore:
      ( 'i' | 'I' ) ( 'g' | 'G' ) ( 'n' | 'N' ) ( 'o' | 'O' )
      ( 'r' | 'R' ) ( 'e' | 'E' )
    ;

nulls:
      ( 'n' | 'N' ) ( 'u' | 'U' ) ( 'l' | 'L' ) ( 'l' | 'L' )
      ( 's' | 'S' )
    ;

unbounded:
      ( 'u' | 'U' ) ( 'n' | 'N' ) ( 'b' | 'B' ) ( 'o' | 'O' ) ( 'u' | 'U' )
      ( 'n' | 'N' ) ( 'd' | 'D' ) ( 'e' | 'E' ) ( 'd' | 'D' )
    ;

all:
      ( 'a' | 'A' ) ( 'l' | 'L' ) ( 'l' | 'L' )
    ;

distinct:
      ( 'd' | 'D' ) ( 'i' | 'I' ) ( 's' | 'S' )
      ( 't' | 'T' ) ( 'i' | 'I' ) ( 'n' | 'N' )
      ( 'c' | 'C' ) ( 't' | 'T' )
    ;

except:
      ( 'e' | 'E' ) ( 'x' | 'X' ) ( 'c' | 'C' ) ( 'e' | 'E' )
      ( 'p' | 'P' ) ( 't' | 'T' )
    ;

first:
      ( 'f' | 'F' ) ( 'i' | 'I' ) ( 'r' | 'R' ) ( 's' | 'S' ) ( 't' | 'T' )
    ;

last:
      ( 'l' | 'L' ) ( 'a' | 'A' ) ( 's' | 'S' ) ( 't' | 'T' )
    ;

replace:
      ( 'r' | 'R' ) ( 'e' | 'E' ) ( 'p' | 'P' ) ( 'l' | 'L' ) ( 'a' | 'A' )
      ( 'c' | 'C' ) ( 'e' | 'E' )
    ;

cast:
      ( 'c' | 'C' ) ( 'a' | 'A' ) ( 's' | 'S' ) ( 't' | 'T' )
    ;

group:
      ( 'g' | 'G' ) ( 'r' | 'R' ) ( 'o' | 'O' ) ( 'u' | 'U' ) ( 'p' | 'P' )
    ;

having:
      ( 'h' | 'H' ) ( 'a' | 'A' ) ( 'v' | 'V' )
      ( 'i' | 'I' ) ( 'n' | 'N' ) ( 'g' | 'G' )
    ;

order:
      ( 'o' | 'O' ) ( 'r' | 'R' ) ( 'd' | 'D' ) ( 'e' | 'E' ) ( 'r' | 'R' )
    ;

by:
      ( 'b' | 'B' ) ( 'y' | 'Y' )
    ;

asc:
      ( 'a' | 'A' ) ( 's' | 'S' ) ( 'c' | 'C' )
    ;

desc:
      ( 'd' | 'D' ) ( 'e' | 'E' ) ( 's' | 'S' ) ( 'c' | 'C' )
    ;

limit:
      ( 'l' | 'L' ) ( 'i' | 'I' ) ( 'm' | 'M' ) ( 'i' | 'I' ) ( 't' | 'T' )
    ;

offset:
      ( 'o' | 'O' ) ( 'f' | 'F' ) ( 'f' | 'F' )
      ( 's' | 'S' ) ( 'e' | 'E' ) ( 't' | 'T' )
    ;

at:
      ( 'a' | 'A' ) ( 't' | 'T' )
    ;

zone:
      ( 'z' | 'Z' ) ( 'o' | 'O' ) ( 'n' | 'N' ) ( 'e' | 'E' )
    ;

case:
      ( 'c' | 'C' ) ( 'a' | 'A' ) ( 's' | 'S' ) ( 'e' | 'E' )
    ;

when:
      ( 'w' | 'W' ) ( 'h' | 'H' ) ( 'e' | 'E' ) ( 'n' | 'N' )
    ;

then:
      ( 't' | 'T' ) ( 'h' | 'H' ) ( 'e' | 'E' ) ( 'n' | 'N' )
    ;

else:
      ( 'e' | 'E' ) ( 'l' | 'L' ) ( 's' | 'S' ) ( 'e' | 'E' )
    ;

end:
      ( 'e' | 'E' ) ( 'n' | 'N' ) ( 'd' | 'D' )
    ;

unnest:
      ( 'u' | 'U' ) ( 'n' | 'N' )
      ( 'n' | 'N' ) ( 'e' | 'E' ) ( 's' | 'S' ) ( 't' | 'T' )
    ;

join:
      ( 'j' | 'J' ) ( 'o' | 'O' ) ( 'i' | 'I' ) ( 'n' | 'N' )
    ;

cross:
      ( 'c' | 'C' ) ( 'r' | 'R' ) ( 'o' | 'O' ) ( 's' | 'S' ) ( 's' | 'S' )
    ;

tablesample:
      ( 't' | 'T' ) ( 'a' | 'A' ) ( 'b' | 'B' ) ( 'l' | 'L' ) ( 'e' | 'E' )
      ( 's' | 'S' ) ( 'a' | 'A' ) ( 'm' | 'M' ) ( 'p' | 'P' ) ( 'l' | 'L' )
      ( 'e' | 'E' )
    ;

percent:
      ( 'p' | 'P' ) ( 'e' | 'E' ) ( 'r' | 'R' ) ( 'c' | 'C' ) ( 'e' | 'E' )
      ( 'n' | 'N' ) ( 't' | 'T' )
    ;

repeatable:
      ( 'r' | 'R' ) ( 'e' | 'E' ) ( 'p' | 'P' ) ( 'e' | 'E' ) ( 'a' | 'A' )
      ( 't' | 'T' ) ( 'a' | 'A' ) ( 'b' | 'B' ) ( 'l' | 'L' ) ( 'e' | 'E' )
    ;


full:
      ( 'f' | 'F' ) ( 'u' | 'U' ) ( 'l' | 'L' ) ( 'l' | 'L' )
    ;

outer:
      ( 'o' | 'O' ) ( 'u' | 'U' ) ( 't' | 'T' ) ( 'e' | 'E' ) ( 'r' | 'R' )
    ;

left:
      ( 'l' | 'L' ) ( 'e' | 'E' ) ( 'f' | 'F' ) ( 't' | 'T' )
    ;

right:
      ( 'r' | 'R' ) ( 'i' | 'I' ) ( 'g' | 'G' ) ( 'h' | 'H' ) ( 't' | 'T' )
    ;

inner:
      ( 'i' | 'I' ) ( 'n' | 'N' ) ( 'n' | 'N' ) ( 'e' | 'E' ) ( 'r' | 'R' )
    ;

using:
      ( 'u' | 'U' ) ( 's' | 'S' ) ( 'i' | 'I' ) ( 'n' | 'N' ) ( 'g' | 'G' )
    ;

on:
      ( 'o' | 'O' ) ( 'n' | 'N' )
    ;

safe_cast:
      ( 's' | 'S' ) ( 'a' | 'A' ) ( 'f' | 'F' ) ( 'e' | 'E' ) '_'
      ( 'c' | 'C' ) ( 'a' | 'A' ) ( 's' | 'S' ) ( 't' | 'T' )
    ;

where:
      ( 'w' | 'W' ) ( 'h' | 'H' ) ( 'e' | 'E' ) ( 'r' | 'R' ) ( 'e' | 'E' )
    ;

weight:
      ( 'w' | 'W' ) ( 'e' | 'E' ) ( 'i' | 'I' )
      ( 'g' | 'G' ) ( 'h' | 'H' ) ( 't' | 'T' )
    ;

window:
      ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'n' | 'N' )
      ( 'd' | 'D' ) ( 'o' | 'O' ) ( 'w' | 'W' )
    ;

extract:
      ( 'e' | 'E' ) ( 'x' | 'X' ) ( 't' | 'T' ) ( 'r' | 'R' )
      ( 'a' | 'A' ) ( 'c' | 'C' ) ( 't' | 'T' )
    ;

over:
      ( 'o' | 'O' ) ( 'v' | 'V' ) ( 'e' | 'E' ) ( 'r' | 'R' )
    ;

interval:
      ( 'i' | 'I' ) ( 'n' | 'N' ) ( 't' | 'T' ) ( 'e' | 'E' ) ( 'r' | 'R' )
      ( 'v' | 'V' ) ( 'a' | 'A' ) ( 'l' | 'L' )
    ;

qualify:
      ( 'q' | 'Q' ) ( 'u' | 'U' ) ( 'a' | 'A' ) ( 'l' | 'L' ) ( 'i' | 'I' )
      ( 'f' | 'F' ) ( 'y' | 'Y' )
    ;

_decimal_literal:
      _decimal_digit { _decimal_digit }
    ;

_decimal_digit:
      '0'-'9'
    ;

_hex_literal:
      '0' ( 'x' | 'X' ) _hex_digit { _hex_digit }
    ;

_hex_digit:
      _decimal_digit | 'a'-'f' | 'A'-'F'
    ;

comment:
      '-' '-' { _single_line_comment_char } [ '\n' ]
    | '#' { _single_line_comment_char } [ '\n' ]
    | '/' '*' { ( . | '*' ) } '*' '/'
    ;

_triple_quoted_string:
      '"' '"' '"' { ( _char | '`' | '\'' | '"' | '\n' ) } '"' '"' '"'
    | '\'' '\'' '\'' { ( _char | '`' | '\'' | '"' | '\n' ) } '\'' '\'' '\''
    ;

_quoted_string:
      '"' { ( _char | '`' | '\'' ) } '"'
    | '\'' { ( _char | '`' | '"' ) } '\''
    ;

_raw_string_value:
      '"' { ( _unescaped_char | '`' | '\'' ) } '"'
    | '\'' { ( _unescaped_char | '`' | '"' ) } '\''
    | '\'' '\'' '\'' { ( _unescaped_char | '`' | '"' ) } '\'' '\'' '\''
    | '"' '"' '"' { ( _unescaped_char | '`' | '"' ) } '"' '"' '"'
    ;

_char:
      _ascii_char | _unicode_value | _byte_value | _escaped_char
    ;

_unescaped_char:
      _ascii_char | _unicode_char | '\\'
    ;

_raw_string:
      _raw_string_prefix _raw_string_value
    ;

/* An arbitrary ASCII character except a few. */
_ascii_char:
      '\x01'-'\x09' /* skip null (0x00) */
    | '\x0B'-'\x21' /* skip line feed (0x0A) */
    | '\x23'-'\x26' /* skip double quote (0x22) */
    | '\x28'-'\x5B' /* skip single quote (0x27) */
    | '\x5D'-'\x5F' /* skip backslash (0x5C) */
    | '\x61'-'\x7F' /* skip backtick (0x60) */
    ;

_unicode_char:
      _ascii_char
    | _unicode_byte
    ;

/* skip invalid code point (\uFFFD) */
_unicode_byte:
      '\u0080'-'\uFFFC'
    | '\uFFFE'-'\U0010FFFF'
    ;

_raw_string_prefix:
      ( 'r' | 'R' )
    ;

_escaped_char:
      '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't'
                 | 'v' | '"' | '?' | '`' | '\\' | '\'' )
    ;

_byte_value:
      _octal_byte_value | _hex_byte_value
    ;

_octal_byte_value:
      '\\' _octal_digit _octal_digit _octal_digit
    ;

_hex_byte_value:
      '\\' { 'x' | 'X' } _hex_digit _hex_digit
    ;

_unicode_value:
      _unicode_char | _little_u_value | _big_u_value
    ;

_big_u_value:
      '\\' 'U'
      _hex_digit _hex_digit _hex_digit _hex_digit
      _hex_digit _hex_digit _hex_digit _hex_digit
    ;

_little_u_value:
      '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit
    ;

_octal_digit:
      '0'-'7'
    ;

_single_line_comment_char:
      '\x01'-'\x09'         /* skip null (0x00) */
    | '\x0B'-'\x7F'         /* skip line feed (0x0A) */
    | '\u0080'-'\uFFFC'
    | '\uFFFE'-'\U0010FFFF' /* skip invalid code point (\uFFFD) */
    ;

identifier:
	  _unquoted_id_char { _unquoted_id_char | _decimal_digit }
    | '`' _quoted_identifier '`'
    ;

_unquoted_id_char:
      _ascii_letter
    | '_'
    ;

/* Letters and digits */
_letter:
      _ascii_letter
    | _unicode_byte
    | '_'
    ;

_ascii_letter:
      'a'-'z'
    | 'A'-'Z'
    ;

_quoted_identifier:
      _quoted_identifier_character
    | _quoted_identifier_character { _quoted_identifier_character }
    ;

_quoted_identifier_character:
      _letter
    | _decimal_digit
    | ' '
    | _symbol
    ;

_symbol:
      '!' | '@' | '#' | '$' | '%' | '^' | '&' | '*' | '(' | ')'
    | '-' | '[' | ']' | '{' | '}' | ':' | ';' | ',' | '.' | '?'
    | '/' | '~' | '<' | '>' | '"' | '\\' | '\''
    ;


_raw_bytes:
      _raw_bytes_prefix _raw_string_value
    ;

_bytes_prefix:
      ( 'b' | 'B' )
    ;

_raw_bytes_prefix:
      ( 'r' | 'R' ) ( 'b' | 'B' )
    | ( 'b' | 'B' ) ( 'r' | 'R' )
    ;

_decimals:
      _decimal_digit { _decimal_digit }
    ;

_exponent:
      ( 'e' | 'E' ) [ '+' | '-' ] _decimals
    ;

!whitespace:
      ' ' | '\t' | '\n' | '\r' | '\u00a0'
    ;

/* Syntax part */

<<
import (
    "github.com/paulourio/bqfmt/zetasql/ast"
	  "github.com/paulourio/bqfmt/zetasql/errors"
	  "github.com/paulourio/bqfmt/zetasql/token"
)
>>

StartMode:
     SQLStatement
    ;

SQLStatement:
      UnterminatedSQLStatement OptSemicolon
    ;

UnterminatedSQLStatement:
      SQLStatementBody
    ;

OptSemicolon:
      ";"
    | empty
    ;

SQLStatementBody:
      QueryStatement
    ;

QueryStatement:
      Query
      << ast.NewQueryStatement($0) >>
    ;

Query:
      QueryPrimaryOrSetOperation
      << ast.NewQuery(nil, $0, nil, nil) >>
    ;

QueryPrimaryOrSetOperation:
      QueryPrimary
    ;

QueryPrimary:
      Select
    ;

Select:
      select
      SelectList
      OptFromClause
      OptWhereClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSelect(false, nil, $1, $2, $3, nil, nil, nil, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    ;

SelectList:
      SelectListPrefix
    | SelectListPrefix ","
    ;

SelectListPrefix:
      SelectColumn
      << ast.NewSelectList($0) >>
    | SelectListPrefix "," SelectColumn
      << WithExtraChild($0, $2) >>
    ;

SelectColumn:
      Expression
      << ast.NewSelectColumn($0, nil) >>
    | Expression as Alias
      <<
      func() (Attrib, error) {
          a, err := UpdateLoc($2, $1)
          if err != nil {
              return nil, err
          }

          return ast.NewSelectColumn($0, a)
      }()
      >>
    | Expression Alias
      << ast.NewSelectColumn($0, $1) >>
    | "*"
      <<
      func() (Attrib, error) {
          s, err := ast.NewStar()
          if err != nil {
              return nil, err
          }

          s.SetImage("*")

          c, err := UpdateLoc(s, $0)
          if err != nil {
              return nil, err
          }

          return ast.NewSelectColumn(c, nil)
      }()
      >>
    ;

Alias:
      Identifier << ast.NewAlias($0) >>
    ;

OptFromClause:
      from FromClauseContents
      <<
      func() (Attrib, error) {
          f, err := ast.NewFromClause($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(f, $0)
      }()
      >>
    | empty
    ;

OptWhereClause:
      WhereClause
    | empty
    ;

WhereClause:
      where Expression
      <<
      func() (Attrib, error) {
          f, err := ast.NewWhereClause($1)
          if err != nil {
              return nil, err
          }

          UpdateLoc(f, $0)
          return f, nil
      }()
      >>
    ;

FromClauseContents:
      TablePrimary
    | FromClauseContents "," TablePrimary
      <<
      func() (Attrib, error) {
          c, err := ast.NewJoin($0, $2, nil, ast.CommaJoin)
          if err != nil {
              return nil, err
          }

          c.ContainsCommaJoin = true

          // Not sure why, but reference implementation sets start
          // location at the comma token.
          c.SetStartLoc($1.(*token.Token).Offset)

          return c, nil
      }()
      >>
    | FromClauseContents JoinType join TablePrimary OptOnOrUsingClauseList
      << ast.NewJoin($0, $3, $4, $1) >>
    ;

TablePrimary:
      TablePathExpression
    | TableSubquery
    ;

TablePathExpression:
      TablePathExpressionBase
      OptPivotOrUnpivotClauseAndAlias
      OptWithOffsetAndAlias
      OptSampleClause
      << NewTablePathExpression($0, $1, $2, $3) >>
    ;

TablePathExpressionBase:
      UnnestExpression
    | MaybeDashedPathExpression
    ;


UnnestExpression:
      unnest "(" Expression ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewUnnestExpression($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $3)
      }()
      >>
    ;

TableSubquery:
      "(" Query ")" OptPivotOrUnpivotClauseAndAlias OptSampleClause
      <<
      func() (Attrib, error) {
          p := $3.(*pivotOrUnpivotAndAlias)

          t, err := ast.NewTableSubquery(
              $1, p.Alias, p.PivotClause, p.UnpivotClause, $4)
          if err != nil {
              return nil, err
          }

          t.Subquery.IsNested = true

          UpdateLoc(t, $0)
          UpdateLoc(t, $2)

          return t, nil
      }()
      >>
    ;

OptPivotOrUnpivotClauseAndAlias:
      as Alias
      <<
      func() (Attrib, error) {
          a, err := UpdateLoc($1, $0)
          if err != nil {
              return nil, err
          }

          return &pivotOrUnpivotAndAlias{Alias: a}, nil
      }()
      >>
    | Alias
      << &pivotOrUnpivotAndAlias{Alias: $0}, nil >>
    | empty
      << &pivotOrUnpivotAndAlias{}, nil >>
    ;

OptWithOffsetAndAlias:
      with offset OptAsAlias
      <<
      func() (Attrib, error) {
          e, err := ast.NewWithOffset($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | empty
    ;

OptAsAlias:
      OptAs Alias
      << UpdateLoc($1, $0) >>
    | empty
    ;

OptAs:
      as
    | empty
    ;

OptOrderByClause:
      OrderByClausePrefix
    | empty
    ;

OrderByClausePrefix:
      order by OrderingExpression
      <<
      func() (Attrib, error) {
          c, err := ast.NewOrderBy($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | OrderByClausePrefix "," OrderingExpression
      << WithExtraChild($0, $2) >>
    ;

OrderingExpression:
      Expression OptAscOrDesc OptNullOrder
      << ast.NewOrderingExpression($0, $1, $3) >>
    ;

OptAscOrDesc:
      asc   << WrapWithLoc(ast.AscendingOrder, $0) >>
    | desc  << WrapWithLoc(ast.DescendingOrder, $0) >>
    | empty << WrapWithLoc(ast.NoOrderingSpec, $0) >>
    ;

OptNullOrder:
      nulls first
      <<
      func() (Attrib, error) {
          e, err := ast.NewNullOrder(true)
          if err != nil {
            return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | nulls last
      <<
      func() (Attrib, error) {
          e, err := ast.NewNullOrder(false)
          if err != nil {
            return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | empty
    ;

OptLimitOffsetClause:
      limit PossiblyCastIntLiteralOrParameter
      offset PossiblyCastIntLiteralOrParameter
      <<
      func() (Attrib, error) {
          c, err := ast.NewLimitOffset($1, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | limit PossiblyCastIntLiteralOrParameter
      <<
      func() (Attrib, error) {
          c, err := ast.NewLimitOffset($1, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | empty
    ;

WindowSpecification:
      Identifier
      << ast.NewWindowSpecification($0, nil, nil, nil) >>
    | "("
      OptIdentifier
      OptPartitionByClause
      OptOrderByClause
      OptWindowFrameClause
      ")"
      <<
      func() (Attrib, error) {
          w, err := ast.NewWindowSpecification($1, $2, $3, $4)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(w, $0, $5)
      }()
      >>
    ;

OptIdentifier:
      Identifier
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      <<
      func() (Attrib, error) {
          c, err := ast.NewPartitionBy($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptWindowFrameClause:
      FrameUnit between WindowFrameBound and WindowFrameBound
    | FrameUnit WindowFrameBound
    | empty
    ;

FrameUnit:
      rows   << WrapWithLoc(ast.Rows, $0) >>
    | range  << WrapWithLoc(ast.Range, $0) >>
    ;

WindowFrameBound:
      unbounded preceding
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.UnboundedPreceding)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | unbounded following
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.UnboundedFollowing)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | current row
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.CurrentRow)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | Expression PrecedingOrFollowing
      << ast.NewWindowFrameExpr($0, $1) >>
    ;

PrecedingOrFollowing:
      preceding  << WrapWithLoc(ast.OffsetPreceding, $0) >>
    | following  << WrapWithLoc(ast.OffsetFollowing, $0) >>
    ;

IntervalExpression:
      interval Expression Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewIntervalExpr($1, $2, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | interval Expression Identifier to Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewIntervalExpr($1, $2, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    ;

Type:
      RawType OptTypeParameters
      <<
      func() (Attrib, error) {
          switch t := $1.(type) {
          case nil:
              return $0, nil
          case *ast.TypeParameterList:
            n := $0.(ast.TypeHandler)
            n.SetTypeParameters(t)
            n.AddChild(t)
            return n, nil
          }

          return nil, errors.ErrMalformedParser
      }()
      >>
    ;

RawType:
      TypeName
    ;

TypeName:
      PathExpression
      << ast.NewNamedType($0) >>
    | ArrayType
    | StructType
    ;

ArrayType:
      array "<" Type ">"
      <<
      func() (Attrib, error) {
          t, err := ast.NewArrayType($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0, $3)
      }()
      >>
    ;

StructType:
      struct "<" ">"
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructType(nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0, $2)
      }()
      >>
    | StructTypePrefix ">"
      << UpdateLoc($0, $1) >>
    ;

StructTypePrefix:
      struct "<" StructField
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructType($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0)
      }()
      >>
    | StructTypePrefix "," StructField
      << WithExtraChild($0, $2) >>
    ;

StructField:
      Identifier Type
      << ast.NewStructField($0, $1) >>
    | Type
      << ast.NewStructField(nil, $0) >>
    ;

/* Expressions are organized by precedence order. */
Expression:
      Expression12
    ;

/* Binary OR operator */
Expression12:
      Expression12 or Expression11
      << ast.NewOrExpr(List($0, $2)) >>
    | Expression11
    ;

/* Binary AND operator */
Expression11:
      Expression11 and Expression10
      << ast.NewAndExpr(List($0, $2)) >>
    | Expression10
    ;

/* Unary NOT operator */
Expression10:
      not Expression9
      <<
      func() (Attrib, error) {
          e, err := ast.NewUnaryExpression(ast.UnaryNot, $1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | Expression9
    ;

/* Comparison operators: eq, lt, le, gt, ge, ne, like, is */
Expression9:
      Expression9 ComparativeOperator Expression8
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression9 LikeOperator Expression8
      << NewLikeBinaryExpression($1, $0, $2) >>
    | Expression9 InOperator Expression8
      << NewInBinaryExpression($1, $0, $2) >>
    | Expression9 BetweenOperator Expression8 and Expression8
      <<
      func() (Attrib, error) {
          b, err := NewBetweenExpression($0, $2, $4, $1)
          if err != nil {
              return nil, err
          }

          return OverrideLoc(b, $1, $4)
      }()
      >>
    | Expression9 IsOperator InExpressionRHS
      << NewIsBinaryExpression($1, $0, $2) >>
    | Expression8
    ;

InExpressionRHS:
      NullLiteral
    | BooleanLiteral
    ;

/* Bitwise OR operator */
Expression8:
      Expression8 "|" Expression7
      << ast.NewBinaryExpression(ast.BinaryBitwiseOr, $0, $2, false) >>
    | Expression7
    ;

/* Bitwise XOR operator */
Expression7:
      Expression7 "^" Expression6
      << ast.NewBinaryExpression(ast.BinaryBitwiseXor, $0, $2, false) >>
    | Expression6
    ;

/* Bitwise AND operator */
Expression6:
      Expression6 "&" Expression5
      << ast.NewBinaryExpression(ast.BinaryBitwiseAnd, $0, $2, false) >>
    | Expression5
    ;

/* Bitwise left and right shift operators. */
Expression5:
      Expression5 ShiftOperator Expression4
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression4
    ;

/* Addition and subtraction operators */
Expression4:
      Expression4 AdditiveOperator Expression3
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3
    ;

/* Multiplication, division, and concatenation operators. */
Expression3:
      Expression3 MultiplicativeOperator Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3 ConcatOp Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression2
    ;

/* Unary operators */
Expression2:
      UnaryOperator Expression
      << ast.NewUnaryExpression($0, $1) >>
    | Expression1
    ;

/* Field access operator, array subscript operator */
Expression1:
      NullLiteral
    | IntegerLiteral
    | BooleanLiteral
    | StringLiteral
    | ParenthesizedExpression
    | ArrayConstructor
    | StructConstructor
    | CastExpression
    | FunctionCallExpressionWithClauses
    | Identifier
      << ast.NewPathExpression($0) >>
    | Expression1 "[" Expression1 "]"
      <<
      func() (Attrib, error) {
          e, err := ast.NewArrayElement($0, $2)
          if err != nil {
              return nil, err
          }

          return OverrideLoc(e, $1, $3)
      }()
      >>
    | Expression1 "." Identifier
      << ExpandPathExpressionOrNewDotIdentifier($0, $1, $2) >>
    ;

LikeOperator:
      like     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not like << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

InOperator:
      in      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not in  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

BetweenOperator:
      between     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not between << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

IsOperator:
      is      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | is not  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

UnaryOperator:
      "+"  << WrapWithLoc(ast.UnaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.UnaryMinus, $0) >>
    | "~"  << WrapWithLoc(ast.UnaryBitwiseNot, $0) >>
    ;

MultiplicativeOperator:
      "*"  << WrapWithLoc(ast.BinaryMultiply, $0) >>
    | "/"  << WrapWithLoc(ast.BinaryDivide, $0) >>
    ;

AdditiveOperator:
      "+"  << WrapWithLoc(ast.BinaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.BinaryMinus, $0) >>
    ;

ConcatOp:
      "||" << WrapWithLoc(ast.BinaryConcat, $0) >>
    ;

ShiftOperator:
      "<<"  << WrapWithLoc(ast.LeftShift, $0) >>
    | ">>"  << WrapWithLoc(ast.RightShift, $0) >>
    ;

IntegerLiteral:
      integer_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewIntLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

StringLiteral:
      string_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewStringLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

FloatingPointLiteral:
      floating_point_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewFloatLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

BytesLiteral:
      bytes_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewBytesLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

BooleanLiteral:
      boolean_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewBooleanLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

NullLiteral:
      null
      <<
      func() (Attrib, error) {
          lit, err := ast.NewNullLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

MaybeDashedPathExpression:
      PathExpression
    | DashedPathExpression
    ;

PathExpression:
      Identifier
      << ast.NewPathExpression($0) >>
    | PathExpression "." Identifier
      << WithExtraChild($0, $2) >>
    ;

DashedPathExpression:
      DashedIdentifier
    | DashedPathExpression "." Identifier
    ;

DashedIdentifier:
      identifier "-" identifier
      << NewDashedIdentifier($0, $1) >>
    ;

Identifier:
      identifier
      << NewIdentifier($0, true) >>
    | KeywordAsIdentifier
      << NewIdentifier($0, true) >>
    ;

KeywordAsIdentifier:
      date
    | numeric_or_decimal
    | extract
    | with
    ;

ParenthesizedExpression:
      "(" Expression ")"
      <<
      func() (Attrib, error) {
          e := $1.(ast.ExpressionHandler)
          e.SetParenthesized(true)

          // Do not include the location in the parentheses. Semantic
          // error messages about this expression should point at the
          // start of the expression, not at the opening parentheses.
          return WrapWithLoc(e, $0, $2)
      }()
      >>
    ;

OptSampleClause:
      SampleClause
    | empty
    ;

SampleClause:
      tablesample Identifier "(" SampleSize ")" OptSampleClauseSuffix
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleClause($1, $2, $3)
          if err != nil {
              return nil, err
          }

          UpdateLoc(s, $0)
          UpdateLoc(s, $4)

          return s, nil
      }()
      >>
    ;

SampleSize:
      SampleSizeValue SampleSizeUnit OptPartitionByClause
      << ast.NewSampleSize($0, $1, $2) >>
    ;

SampleSizeValue:
      PossiblyCastIntLiteralOrParameter
    | FloatingPointLiteral
    ;

SampleSizeUnit:
      rows     << WrapWithLoc(ast.RowsSampling, $0) >>
    | percent  << WrapWithLoc(ast.PercentSampling, $0) >>
    ;

OptSampleClauseSuffix:
      RepeatableClause
      << ast.NewSampleSuffix(nil, $0) >>
    | with weight OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix(nil, $2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | with weight Alias OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix($2, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | with weight as Alias OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix($3, $4)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | empty
    ;

OptRepeatableClause:
      RepeatableClause
    | empty
    ;

RepeatableClause:
      repeatable "(" PossiblyCastIntLiteralOrParameter ")"
      <<
      func() (Attrib, error) {
          c, err := ast.NewRepeatableClause($2)
          if err != nil {
              return nil, err
          }

          UpdateLoc(c, $0, $3)
          return c, nil
      }()
      >>
    ;

PossiblyCastIntLiteralOrParameter:
      CastIntLiteralOrParameter
    | IntLiteralOrParameter
    ;

CastIntLiteralOrParameter:
      cast "(" IntLiteralOrParameter as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, false)
          if err != nil {
              return nil, err
          }

          UpdateLoc(e, $0, $6)
          return e, nil
      }()
      >>
    ;

IntLiteralOrParameter:
      IntegerLiteral
    | ParameterExpression
    ;

ParameterExpression:
      NamedParameterExpression
    ;

NamedParameterExpression:
      "@" Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewParameterExpr($0)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | "@" KeywordAsIdentifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewParameterExpr($0)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    ;

OptFormat:
      format Expression OptAtTimeZone
      <<
      func() (Attrib, error) {
          f, err := ast.NewFormatClause($1, $2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(f, $0)
      }()
      >>
    | empty
    ;

OptAtTimeZone:
      at time zone Expression << $3, nil >>
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      <<
      func() (Attrib, error) {
          c, err := ast.NewPartitionBy($2)
          if err != nil { return nil, err }
          return UpdateLoc(c, $0)
      }()
      >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptTypeParameters:
      TypeParametersPrefix ")"
      << UpdateLoc($0, $1) >>
    | empty
    ;

TypeParametersPrefix:
      "(" TypeParameter
      <<
      func() (Attrib, error) {
          e, err := ast.NewTypeParameterList($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | TypeParametersPrefix "," TypeParameter
      << WithExtraChild($0, $2) >>
    ;

TypeParameter:
      IntegerLiteral
    | BooleanLiteral
    | StringLiteral
    | BytesLiteral
    | FloatingPointLiteral
    ;

OptOnOrUsingClauseList:
      OnOrUsingClause
      << ast.NewOnOrUsingClauseList($0) >>
    | OptOnOrUsingClauseList OnOrUsingClause
      << WithExtraChild($0, $1) >>
    ;

OnOrUsingClause:
      OnClause
    | UsingClause
    ;

OnClause:
      on Expression << $1, nil >>
    ;

UsingClause:
      UsingClausePrefix ")"
    ;

UsingClausePrefix:
      using "(" Identifier
      <<
      func() (Attrib, error) {
          c, err := ast.NewUsingClause($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | UsingClausePrefix "," Identifier
      << WithExtraChild($0, $2) >>
    ;

JoinType:
      cross           << WrapWithLoc(ast.CrossJoin, $0) >>
    | full OptOuter   << WrapWithLoc(ast.FullJoin, $0, $1) >>
    | inner           << WrapWithLoc(ast.InnerJoin, $0) >>
    | left OptOuter   << WrapWithLoc(ast.LeftJoin, $0, $1) >>
    | right OptOuter  << WrapWithLoc(ast.RightJoin, $0, $1) >>
    | empty OptOuter  << WrapWithLoc(ast.DefaultJoin, $0, $1) >>
    ;

OptOuter:
      outer
    | empty
    ;

FunctionCallExpressionWithClauses:
      FunctionCallExpression OptOverClause
      <<
      func() (Attrib, error) {
          if $1 != nil {
              return ast.NewAnalyticFunctionCall($0, $1)
          }

          return $0, nil
      }()
      >>
    ;

FunctionCallExpression:
      /* Empty argument list */
      FunctionCallExpressionBase
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      <<
      func() (Attrib, error) {
          f := $0.(*ast.FunctionCall)

          if $1 != nil {
              err := f.InitOrderBy($1)
              if err != nil {
                  return nil, err
              }
          }

          if $2 != nil {
              err := f.InitLimitOffset($2)
              if err != nil {
                  return nil, err
              }
          }

          return UpdateLoc(f, $3)
      }()
      >>
      /* Non-empty argument list. */
    | FunctionCallExpressionWithArgsPrefix
      OptNullHandlingModifier
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      <<
      func() (Attrib, error) {
          f := $0.(*ast.FunctionCall)

          if $1 != nil {
              err := f.InitNullHandlingModifier($1)
              if err != nil {
                  return nil, err
              }
          }

          if $2 != nil {
              err := f.InitOrderBy($2)
              if err != nil {
                  return nil, err
              }
          }

          if $3 != nil {
              err := f.InitLimitOffset($3)
              if err != nil {
                  return nil, err
              }
          }

          return UpdateLoc(f, $4)
      }()
      >>
    ;

FunctionCallExpressionWithArgsPrefix:
      FunctionCallExpressionBase FunctionCallArgument
      << WithExtraChild($0, $1) >>
    | FunctionCallExpressionBase "*"
      <<
      func() (Attrib, error) {
          s, err := ast.NewStar()
          if err != nil {
              return nil, err
          }

          s.SetImage("*")

          l, err := UpdateLoc(s, $1)
          if err != nil {
              return nil, err
          }

          return WithExtraChild($0, l)
      }()
      >>
    | FunctionCallExpressionWithArgsPrefix "," FunctionCallArgument
      << WithExtraChild($0, $2) >>
    ;

FunctionCallExpressionBase:
      Expression "(" distinct
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, true)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $2)
      }()
      >>
    | Expression "("
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, false)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $1)
      }()
      >>
    ;

FunctionCallArgument:
      Expression
    ;

OptNullHandlingModifier:
      ignore nulls
      << WrapWithLoc(ast.IgnoreNulls, $0, $1) >>
    | respect nulls
      << WrapWithLoc(ast.RespectNulls, $0, $1) >>
    | empty
      << ast.DefaultNullHandling, nil >>
    ;

OptOverClause:
      OverClause
    | empty
    ;

OverClause:
      over WindowSpecification
      << UpdateLoc($1, $0) >>
    ;

CastExpression:
      cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, false)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(e, $0, $6)
      }()
      >>
    | safe_cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, true)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(e, $0, $6)
      }()
      >>
    ;

ArrayConstructor:
      ArrayConstructorPrefixNoExpressions "]"
      << UpdateLoc($0, $1) >>
    | ArrayConstructorPrefix "]"
      << UpdateLoc($0, $1) >>
    ;

ArrayConstructorPrefixNoExpressions:
      array "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $0, $1)
      }()
      >>
    | "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $0)
      }()
      >>
    | ArrayType "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor($0)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $1)
      }()
      >>
    ;

ArrayConstructorPrefix:
      ArrayConstructorPrefixNoExpressions Expression
      << WithExtraChild($0, $1) >>
    | ArrayConstructorPrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructor:
      StructConstructorPrefix ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithKeywordNoArg ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithoutKeyword ")"
      << UpdateLoc($0, $1) >>
    ;

StructConstructorPrefix:
      StructConstructorPrefixWithKeyword
    | StructConstructorPrefixWithKeywordNoArg
    | StructConstructorPrefixWithoutKeyword
    ;

StructConstructorPrefixWithKeyword:
      StructConstructorPrefixWithKeywordNoArg StructConstructorArg
    ;

StructConstructorPrefixWithKeywordNoArg:
      StructType "("
      << ast.NewStructConstructorWithKeyword($0) >>
    | struct "("
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithKeyword(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    ;

StructConstructorPrefixWithoutKeyword:
      "(" Expression "," Expression
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithParens(List($1, $3))
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    | StructConstructorPrefixWithoutKeyword "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructorArg:
      Expression OptAsAliasWithRequiredAs
      << ast.NewStructConstructorArg($0, $1) >>
    ;

OptAsAliasWithRequiredAs:
      as Identifier
      <<
      func() (Attrib, error) {
          a, err := ast.NewAlias($1)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(a, $0)
      }()
      >>
    | empty
    ;

ComparativeOperator:
      "="   << WrapWithLoc(ast.BinaryEq, $0) >>
    | "!="  << WrapWithLoc(ast.BinaryNE, $0) >>
    | "<>"  << WrapWithLoc(ast.BinaryNE2, $0) >>
    | "<"   << WrapWithLoc(ast.BinaryLT, $0) >>
    | "<="  << WrapWithLoc(ast.BinaryLE, $0) >>
    | ">"   << WrapWithLoc(ast.BinaryGT, $0) >>
    | ">="  << WrapWithLoc(ast.BinaryGE, $0) >>
    ;