/* Lexical part */

/* String and bytes literals */
string_literal: [_raw_string_prefix](_sqtext|_sq3text|_dqtext|_dq3text) ;
bytes_literal:  (_bytes_prefix|_raw_bytes_prefix)(_sqtext|_sq3text|_dqtext|_dq3text) ;

unterminated_string_literal:                    _sqtext_0|_dqtext_0 ;
unterminated_triple_quoted_string_literal:      _sq3text_0|_dq3text_0 ;
unterminated_raw_string_literal:                _raw_string_prefix(_sqtext_0|_dqtext_0) ;
unterminated_triple_quoted_raw_string_literal:  _raw_string_prefix(_sq3text_0|_dq3text_0) ;
unterminated_bytes_literal:                     _bytes_prefix(_sqtext_0|_dqtext_0) ;
unterminated_raw_bytes_literal:                 _raw_bytes_prefix(_sqtext_0|_dqtext_0) ;
unterminated_triple_quoted_bytes_literal:       _bytes_prefix(_sq3text_0|_dq3text_0) ;
unterminated_triple_quoted_raw_bytes_literal:   _raw_bytes_prefix(_sq3text_0|_dq3text_0) ;

/*
    The abbreviations here:
      sq = single quote
      dq = double quote
      bq = backtick quote
      3  = triple quote
      _0 = unterminated versions.  They are used to return better error
            messages for unterminated strings and bytes.

    Here we accept arbitrary escapes instead of trying to narrowing it
    down just de valid set.  The actual validation of the escapes, and
    of things like UTF-8 structure, is done in the parser.
 */
_sqtext:      _sqtext_0 _sq ;
_sqtext_0:    _sq{(_no_backslash_sq_newline|_any_escape)} ;
_dqtext:      _dqtext_0 _dq ;
_dqtext_0:    _dq{(_no_backslash_dq_newline|_any_escape)} ;
_sq3text:     _sq3text_0 _sq3 ;
_sq3text_0:   _sq3{[(_sq|(_sq _sq))](_no_backslash_sq|_any_escape)} ;
_dq3text:     _dq3text_0 _dq3 ;
_dq3text_0:   _dq3{[(_dq|(_dq _dq))](_no_backslash_dq|_any_escape)} ;

_any_escape:              '\\'(_ascii_char|'"'|'\''|'\\'|'\n'|'\r');
_raw_string_prefix:       ('r'|'R') ;
_raw_bytes_prefix:        (('r'|'R')('b'|'B')) | (('b'|'B')('r'|'R')) ;
_bytes_prefix:            ('b'|'B') ;
_no_backslash_sq_newline: _char|'"' ;
_no_backslash_dq_newline: _char|'\'' ;
_no_backslash_sq:         _char|_dq|'\n' ;
_no_backslash_dq:         _char|_sq|'\n' ;
_sq3:                     _sq _sq _sq ;
_dq3:                     _dq _dq _dq ;
_sq:                      '\'' ;
_dq:                      '"' ;

_char:              _ascii_char|_unicode_byte ;
_ascii_char:        '\x01'-'\x09' /* skip null (0x00) */
                  | '\x0B'-'\x21' /* skip line feed (0x0A) */
                  | '\x23'-'\x26' /* skip double quote (0x22) */
                  | '\x28'-'\x5B' /* skip single quote (0x27) */
                  | '\x5D'-'\x7F' /* skip backslash (0x5C) */
                  ;
_unicode_byte:    '\u0080'-'\uFFFC'|'\uFFFE'-'\U0010FFFF' ;

/* Integer literals */
integer_literal: _int_literal ;

missing_whitespace_int_and_alias: _int_literal('a'-'z'|'A'-'Z'|'_') ;

_int_literal: (_decimal_literal|_hex_literal) ;

/* Floating-point literals */
floating_point_literal: _float_literal ;

missing_whitespace_float_and_alias: _float_literal('a'-'z'|'A'-'Z'|'_') ;

_float_literal:     _decimals'.'[_decimals][_exponent]
                  | _decimals _exponent
                  | '.'_decimals[_exponent]
                  ;
_decimals:        _decimal_digit{_decimal_digit} ;
_exponent:        ('e'|'E')['+'|'-']_decimals ;
_decimal_literal: _decimal_digit{_decimal_digit} ;
_decimal_digit:   '0'-'9' ;
_hex_literal:     '0'('x'|'X')_hex_digit{_hex_digit} ;
_hex_digit:       _decimal_digit|'a'-'f'|'A'-'F' ;

/* Boolean literals */
boolean_literal: ('f'|'F')('a'|'A')('l'|'L')('s'|'S')('e'|'E')
               | ('t'|'T')('r'|'R')('u'|'U')('e'|'E')
               ;

/* Numeric and decimal prefixes */
numeric_or_decimal:
      ('n'|'N')('u'|'U')('m'|'M')('e'|'E')('r'|'R')('i'|'I')('c'|'C')
    | ('d'|'D')('e'|'E')('c'|'C')('i'|'I')('m'|'M')('a'|'A')('l'|'L')
    ;

bignumeric_or_bigdecimal:
      ('b'|'B')('i'|'I')('g'|'G')('n'|'N')('u'|'U')
      ('m'|'M')('e'|'E')('r'|'R')('i'|'I')('c'|'C')
    | ('b'|'B')('i'|'I')('g'|'G')('d'|'D')('e'|'E')
      ('c'|'C')('i'|'I')('m'|'M')('a'|'A')('l'|'L')
    ;

/* Case-insensitive words */
all:        ('a'|'A')('l'|'L')('l'|'L') ;
and:        ('a'|'A')('n'|'N')('d'|'D') ;
array:      ('a'|'A')('r'|'R')('r'|'R')('a'|'A')('y'|'Y') ;
as:         ('a'|'A')('s'|'S') ;
asc:        ('a'|'A')('s'|'S')('c'|'C') ;
at:         ('a'|'A')('t'|'T') ;
between:    ('b'|'B')('e'|'E')('t'|'T')('w'|'W')('e'|'E')('e'|'E')('n'|'N') ;
by:         ('b'|'B')('y'|'Y') ;
case:       ('c'|'C')('a'|'A')('s'|'S')('e'|'E') ;
cast:       ('c'|'C')('a'|'A')('s'|'S')('t'|'T') ;
cross:      ('c'|'C')('r'|'R')('o'|'O')('s'|'S')('s'|'S') ;
current:    ('c'|'C')('u'|'U')('r'|'R')('r'|'R')('e'|'E')('n'|'N')('t'|'T') ;
date:       ('d'|'D')('a'|'A')('t'|'T')('e'|'E') ;
datetime:   ('d'|'D')('a'|'A')('t'|'T')('e'|'E')('t'|'T')('i'|'I')('m'|'M')('e'|'E') ;
desc:       ('d'|'D')('e'|'E')('s'|'S')('c'|'C') ;
distinct:   ('d'|'D')('i'|'I')('s'|'S')('t'|'T')('i'|'I')('n'|'N')('c'|'C')('t'|'T') ;
else:       ('e'|'E')('l'|'L')('s'|'S')('e'|'E') ;
end:        ('e'|'E')('n'|'N')('d'|'D') ;
except:     ('e'|'E')('x'|'X')('c'|'C')('e'|'E')('p'|'P')('t'|'T') ;
extract:    ('e'|'E')('x'|'X')('t'|'T')('r'|'R')('a'|'A')('c'|'C')('t'|'T') ;
first:      ('f'|'F')('i'|'I')('r'|'R')('s'|'S')('t'|'T') ;
following:  ('f'|'F')('o'|'O')('l'|'L')('l'|'L')('o'|'O')('w'|'W')('i'|'I')('n'|'N')('g'|'G') ;
format:     ('f'|'F')('o'|'O')('r'|'R')('m'|'M')('a'|'A')('t'|'T') ;
from:       ('f'|'F')('r'|'R')('o'|'O')('m'|'M') ;
full:       ('f'|'F')('u'|'U')('l'|'L')('l'|'L') ;
group:      ('g'|'G')('r'|'R')('o'|'O')('u'|'U')('p'|'P') ;
having:     ('h'|'H')('a'|'A')('v'|'V')('i'|'I')('n'|'N')('g'|'G') ;
ignore:     ('i'|'I')('g'|'G')('n'|'N')('o'|'O')('r'|'R')('e'|'E') ;
in:         ('i'|'I')('n'|'N') ;
inner:      ('i'|'I')('n'|'N')('n'|'N')('e'|'E')('r'|'R') ;
intersect:  ('i'|'I')('n'|'N')('t'|'T')('e'|'E')('r'|'R')('s'|'S')('e'|'E')('c'|'C')('t'|'T') ;
interval:   ('i'|'I')('n'|'N')('t'|'T')('e'|'E')('r'|'R')('v'|'V')('a'|'A')('l'|'L') ;
is:         ('i'|'I')('s'|'S') ;
join:       ('j'|'J')('o'|'O')('i'|'I')('n'|'N') ;
json:       ('j'|'J')('s'|'S')('o'|'O')('n'|'N') ;
last:       ('l'|'L')('a'|'A')('s'|'S')('t'|'T') ;
left:       ('l'|'L')('e'|'E')('f'|'F')('t'|'T') ;
like:       ('l'|'L')('i'|'I')('k'|'K')('e'|'E') ;
limit:      ('l'|'L')('i'|'I')('m'|'M')('i'|'I')('t'|'T') ;
not:        ('n'|'N')('o'|'O')('t'|'T') ;
null:       ('n'|'N')('u'|'U')('l'|'L')('l'|'L') ;
nulls:      ('n'|'N')('u'|'U')('l'|'L')('l'|'L')('s'|'S') ;
offset:     ('o'|'O')('f'|'F')('f'|'F')('s'|'S')('e'|'E')('t'|'T') ;
on:         ('o'|'O')('n'|'N') ;
or:         ('o'|'O')('r'|'R') ;
order:      ('o'|'O')('r'|'R')('d'|'D')('e'|'E')('r'|'R') ;
outer:      ('o'|'O')('u'|'U')('t'|'T')('e'|'E')('r'|'R') ;
over:       ('o'|'O')('v'|'V')('e'|'E')('r'|'R') ;
partition:  ('p'|'P')('a'|'A')('r'|'R')('t'|'T')('i'|'I')('t'|'T')('i'|'I')('o'|'O')('n'|'N') ;
percent:    ('p'|'P')('e'|'E')('r'|'R')('c'|'C')('e'|'E')('n'|'N')('t'|'T') ;
preceding:  ('p'|'P')('r'|'R')('e'|'E')('c'|'C')('e'|'E')('d'|'D')('i'|'I')('n'|'N')('g'|'G') ;
qualify:    ('q'|'Q')('u'|'U')('a'|'A')('l'|'L')('i'|'I')('f'|'F')('y'|'Y') ;
range:      ('r'|'R')('a'|'A')('n'|'N')('g'|'G')('e'|'E') ;
repeatable: ('r'|'R')('e'|'E')('p'|'P')('e'|'E')('a'|'A')('t'|'T')('a'|'A')('b'|'B')('l'|'L')('e'|'E') ;
replace:    ('r'|'R')('e'|'E')('p'|'P')('l'|'L')('a'|'A')('c'|'C')('e'|'E') ;
respect:    ('r'|'R')('e'|'E')('s'|'S')('p'|'P')('e'|'E')('c'|'C')('t'|'T') ;
right:      ('r'|'R')('i'|'I')('g'|'G')('h'|'H')('t'|'T') ;
row:        ('r'|'R')('o'|'O')('w'|'W') ;
rows:       ('r'|'R')('o'|'O')('w'|'W')('s'|'S') ;
safe_cast:  ('s'|'S')('a'|'A')('f'|'F')('e'|'E')'_'('c'|'C')('a'|'A')('s'|'S')('t'|'T') ;
select:     ('s'|'S')('e'|'E')('l'|'L')('e'|'E')('c'|'C')('t'|'T') ;
struct:     ('s'|'S')('t'|'T')('r'|'R')('u'|'U')('c'|'C')('t'|'T') ;
tablesample: ('t'|'T')('a'|'A')('b'|'B')('l'|'L')('e'|'E')('s'|'S')('a'|'A')('m'|'M')('p'|'P')('l'|'L')('e'|'E') ;
then:       ('t'|'T')('h'|'H')('e'|'E')('n'|'N') ;
time:       ('t'|'T')('i'|'I')('m'|'M')('e'|'E') ;
timestamp:  ('t'|'T')('i'|'I')('m'|'M')('e'|'E')('s'|'S')('t'|'T')('a'|'A')('m'|'M')('p'|'P') ;
to:         ('t'|'T')('o'|'O') ;
unbounded:  ('u'|'U')('n'|'N')('b'|'B')('o'|'O')('u'|'U')('n'|'N')('d'|'D')('e'|'E')('d'|'D') ;
union:      ('u'|'U')('n'|'N')('i'|'I')('o'|'O')('n'|'N') ;
unnest:     ('u'|'U')('n'|'N')('n'|'N')('e'|'E')('s'|'S')('t'|'T') ;
using:      ('u'|'U')('s'|'S')('i'|'I')('n'|'N')('g'|'G') ;
weight:     ('w'|'W')('e'|'E')('i'|'I')('g'|'G')('h'|'H')('t'|'T') ;
when:       ('w'|'W')('h'|'H')('e'|'E')('n'|'N') ;
where:      ('w'|'W')('h'|'H')('e'|'E')('r'|'R')('e'|'E') ;
window:     ('w'|'W')('i'|'I')('n'|'N')('d'|'D')('o'|'O')('w'|'W') ;
with:       ('w'|'W')('i'|'I')('t'|'T')('h'|'H') ;
zone:       ('z'|'Z')('o'|'O')('n'|'N')('e'|'E') ;

comment: '-''-'{_single_line_comment_char}['\n']
       | '#'{_single_line_comment_char}['\n']
       | _cs_comment
       ;

unterminated_comment: _cs_comment_begin ;

/* C-style comments using slash+star */
_cs_comment:        _cs_comment_begin'*'{'*'}'/' ;
_cs_comment_begin:  '/''*'{(.|'*')} ;

_single_line_comment_char:
      '\x01'-'\x09'         /* skip null (0x00) */
    | '\x0B'-'\x7F'         /* skip line feed (0x0A) */
    | '\u0080'-'\uFFFC'
    | '\uFFFE'-'\U0010FFFF' /* skip invalid code point (\uFFFD) */
    ;

identifier: _unquoted_identifier|_bqtext ;

unterminated_escaped_identifier: _bqtext_0;

_unquoted_identifier: _id_0{(_id_0|'0'-'9')} ;
_id_0:      'a'-'z'|'A'-'Z'|'_' ;
_bqtext_0:  _bq{(_id_char|_any_escape)} ;
_bqtext:    _bqtext_0 _bq ;
_bq:        '`' ;
_id_char:   '\x01'-'\x09' /* skip null (0x00) */
          | '\x0B'-'\x5B' /* skip line feed (0x0A) */
          | '\x5D'-'\x5F' /* skip backslash (0x5C) */
          | '\x61'-'\x7F' /* skip backtick (0x60) */
          ;

!whitespace: ' '|'\t'|'\n'|'\r'|'\u00a0' ;

illegal_character: . ;

/* Syntax part */

<<
import (
    "github.com/paulourio/bqfmt/zetasql/ast"
	  "github.com/paulourio/bqfmt/zetasql/errors"
	  "github.com/paulourio/bqfmt/zetasql/token"
)
>>

StartMode:
     SQLStatement
    ;

SQLStatement:
      UnterminatedSQLStatement OptSemicolon
    ;

UnterminatedSQLStatement:
      SQLStatementBody
    ;

OptSemicolon:
      ";"
    | empty
    ;

SQLStatementBody:
      QueryStatement
    ;

QueryStatement:
      Query
      << ast.NewQueryStatement($0) >>
    ;

Query:
      QueryPrimaryOrSetOperation
      << ast.NewQuery(nil, $0, nil, nil) >>
    ;

QueryPrimaryOrSetOperation:
      QueryPrimary
    ;

QueryPrimary:
      Select
    ;

Select:
      select
      SelectList
      OptFromClause
      OptWhereClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSelect(false, nil, $1, $2, $3, nil, nil, nil, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    ;

SelectList:
      SelectListPrefix
    | SelectListPrefix ","
    ;

SelectListPrefix:
      SelectColumn
      << ast.NewSelectList($0) >>
    | SelectListPrefix "," SelectColumn
      << WithExtraChild($0, $2) >>
    ;

SelectColumn:
      Expression
      << ast.NewSelectColumn($0, nil) >>
    | Expression as Alias
      <<
      func() (Attrib, error) {
          a, err := UpdateLoc($2, $1)
          if err != nil {
              return nil, err
          }

          return ast.NewSelectColumn($0, a)
      }()
      >>
    | Expression Alias
      << ast.NewSelectColumn($0, $1) >>
    | "*"
      <<
      func() (Attrib, error) {
          s, err := ast.NewStar()
          if err != nil {
              return nil, err
          }

          s.SetImage("*")

          c, err := UpdateLoc(s, $0)
          if err != nil {
              return nil, err
          }

          return ast.NewSelectColumn(c, nil)
      }()
      >>
    ;

Alias:
      Identifier << ast.NewAlias($0) >>
    ;

OptFromClause:
      from FromClauseContents
      <<
      func() (Attrib, error) {
          f, err := ast.NewFromClause($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(f, $0)
      }()
      >>
    | empty
    ;

OptWhereClause:
      WhereClause
    | empty
    ;

WhereClause:
      where Expression
      <<
      func() (Attrib, error) {
          f, err := ast.NewWhereClause($1)
          if err != nil {
              return nil, err
          }

          UpdateLoc(f, $0)
          return f, nil
      }()
      >>
    ;

FromClauseContents:
      TablePrimary
    | FromClauseContents "," TablePrimary
      <<
      func() (Attrib, error) {
          c, err := ast.NewJoin($0, $2, nil, ast.CommaJoin)
          if err != nil {
              return nil, err
          }

          c.ContainsCommaJoin = true

          // Not sure why, but reference implementation sets start
          // location at the comma token.
          c.SetStartLoc($1.(*token.Token).Offset)

          return c, nil
      }()
      >>
    | FromClauseContents JoinType join TablePrimary OptOnOrUsingClauseList
      << ast.NewJoin($0, $3, $4, $1) >>
    ;

TablePrimary:
      TablePathExpression
    | TableSubquery
    ;

TablePathExpression:
      TablePathExpressionBase
      OptPivotOrUnpivotClauseAndAlias
      OptWithOffsetAndAlias
      OptSampleClause
      << NewTablePathExpression($0, $1, $2, $3) >>
    ;

TablePathExpressionBase:
      UnnestExpression
    | MaybeDashedPathExpression
    ;


UnnestExpression:
      unnest "(" Expression ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewUnnestExpression($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $3)
      }()
      >>
    ;

TableSubquery:
      "(" Query ")" OptPivotOrUnpivotClauseAndAlias OptSampleClause
      <<
      func() (Attrib, error) {
          p := $3.(*pivotOrUnpivotAndAlias)

          t, err := ast.NewTableSubquery(
              $1, p.Alias, p.PivotClause, p.UnpivotClause, $4)
          if err != nil {
              return nil, err
          }

          t.Subquery.IsNested = true

          UpdateLoc(t, $0)
          UpdateLoc(t, $2)

          return t, nil
      }()
      >>
    ;

OptPivotOrUnpivotClauseAndAlias:
      as Alias
      <<
      func() (Attrib, error) {
          a, err := UpdateLoc($1, $0)
          if err != nil {
              return nil, err
          }

          return &pivotOrUnpivotAndAlias{Alias: a}, nil
      }()
      >>
    | Alias
      << &pivotOrUnpivotAndAlias{Alias: $0}, nil >>
    | empty
      << &pivotOrUnpivotAndAlias{}, nil >>
    ;

OptWithOffsetAndAlias:
      with offset OptAsAlias
      <<
      func() (Attrib, error) {
          e, err := ast.NewWithOffset($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | empty
    ;

OptAsAlias:
      OptAs Alias
      << UpdateLoc($1, $0) >>
    | empty
    ;

OptAs:
      as
    | empty
    ;

OptOrderByClause:
      OrderByClausePrefix
    | empty
    ;

OrderByClausePrefix:
      order by OrderingExpression
      <<
      func() (Attrib, error) {
          c, err := ast.NewOrderBy($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | OrderByClausePrefix "," OrderingExpression
      << WithExtraChild($0, $2) >>
    ;

OrderingExpression:
      Expression OptAscOrDesc OptNullOrder
      << ast.NewOrderingExpression($0, $1, $3) >>
    ;

OptAscOrDesc:
      asc   << WrapWithLoc(ast.AscendingOrder, $0) >>
    | desc  << WrapWithLoc(ast.DescendingOrder, $0) >>
    | empty << WrapWithLoc(ast.NoOrderingSpec, $0) >>
    ;

OptNullOrder:
      nulls first
      <<
      func() (Attrib, error) {
          e, err := ast.NewNullOrder(true)
          if err != nil {
            return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | nulls last
      <<
      func() (Attrib, error) {
          e, err := ast.NewNullOrder(false)
          if err != nil {
            return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | empty
    ;

OptLimitOffsetClause:
      limit PossiblyCastIntLiteralOrParameter
      offset PossiblyCastIntLiteralOrParameter
      <<
      func() (Attrib, error) {
          c, err := ast.NewLimitOffset($1, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | limit PossiblyCastIntLiteralOrParameter
      <<
      func() (Attrib, error) {
          c, err := ast.NewLimitOffset($1, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | empty
    ;

WindowSpecification:
      Identifier
      << ast.NewWindowSpecification($0, nil, nil, nil) >>
    | "("
      OptIdentifier
      OptPartitionByClause
      OptOrderByClause
      OptWindowFrameClause
      ")"
      <<
      func() (Attrib, error) {
          w, err := ast.NewWindowSpecification($1, $2, $3, $4)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(w, $0, $5)
      }()
      >>
    ;

OptIdentifier:
      Identifier
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      <<
      func() (Attrib, error) {
          c, err := ast.NewPartitionBy($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptWindowFrameClause:
      FrameUnit between WindowFrameBound and WindowFrameBound
    | FrameUnit WindowFrameBound
    | empty
    ;

FrameUnit:
      rows   << WrapWithLoc(ast.Rows, $0) >>
    | range  << WrapWithLoc(ast.Range, $0) >>
    ;

WindowFrameBound:
      unbounded preceding
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.UnboundedPreceding)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | unbounded following
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.UnboundedFollowing)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | current row
      <<
      func() (Attrib, error) {
          e, err := ast.NewWindowFrameExpr(nil, ast.CurrentRow)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0, $1)
      }()
      >>
    | Expression PrecedingOrFollowing
      << ast.NewWindowFrameExpr($0, $1) >>
    ;

PrecedingOrFollowing:
      preceding  << WrapWithLoc(ast.OffsetPreceding, $0) >>
    | following  << WrapWithLoc(ast.OffsetFollowing, $0) >>
    ;

IntervalExpression:
      interval Expression Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewIntervalExpr($1, $2, nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | interval Expression Identifier to Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewIntervalExpr($1, $2, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    ;

Type:
      RawType OptTypeParameters
      <<
      func() (Attrib, error) {
          switch t := $1.(type) {
          case nil:
              return $0, nil
          case *ast.TypeParameterList:
            n := $0.(ast.TypeHandler)
            n.SetTypeParameters(t)
            n.AddChild(t)
            return n, nil
          }

          return nil, errors.ErrMalformedParser
      }()
      >>
    ;

RawType:
      TypeName
    ;

TypeName:
      PathExpression
      << ast.NewNamedType($0) >>
    | ArrayType
    | StructType
    ;

ArrayType:
      array "<" Type ">"
      <<
      func() (Attrib, error) {
          t, err := ast.NewArrayType($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0, $3)
      }()
      >>
    ;

StructType:
      struct "<" ">"
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructType(nil)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0, $2)
      }()
      >>
    | StructTypePrefix ">"
      << UpdateLoc($0, $1) >>
    ;

StructTypePrefix:
      struct "<" StructField
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructType($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(t, $0)
      }()
      >>
    | StructTypePrefix "," StructField
      << WithExtraChild($0, $2) >>
    ;

StructField:
      Identifier Type
      << ast.NewStructField($0, $1) >>
    | Type
      << ast.NewStructField(nil, $0) >>
    ;

/* Expressions are organized by precedence order. */
Expression:
      Expression12
    ;

/* Binary OR operator */
Expression12:
      Expression12 or Expression11
      << ast.NewOrExpr(List($0, $2)) >>
    | Expression11
    ;

/* Binary AND operator */
Expression11:
      Expression11 and Expression10
      << ast.NewAndExpr(List($0, $2)) >>
    | Expression10
    ;

/* Unary NOT operator */
Expression10:
      not Expression9
      <<
      func() (Attrib, error) {
          e, err := ast.NewUnaryExpression(ast.UnaryNot, $1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | Expression9
    ;

/* Comparison operators: eq, lt, le, gt, ge, ne, like, is */
Expression9:
      Expression9 ComparativeOperator Expression8
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression9 LikeOperator Expression8
      << NewLikeBinaryExpression($1, $0, $2) >>
    | Expression9 InOperator Expression8
      << NewInBinaryExpression($1, $0, $2) >>
    | Expression9 BetweenOperator Expression8 and Expression8
      <<
      func() (Attrib, error) {
          b, err := NewBetweenExpression($0, $2, $4, $1)
          if err != nil {
              return nil, err
          }

          return OverrideLoc(b, $1, $4)
      }()
      >>
    | Expression9 IsOperator InExpressionRHS
      << NewIsBinaryExpression($1, $0, $2) >>
    | Expression8
    ;

InExpressionRHS:
      NullLiteral
    | BooleanLiteral
    ;

/* Bitwise OR operator */
Expression8:
      Expression8 "|" Expression7
      << ast.NewBinaryExpression(ast.BinaryBitwiseOr, $0, $2, false) >>
    | Expression7
    ;

/* Bitwise XOR operator */
Expression7:
      Expression7 "^" Expression6
      << ast.NewBinaryExpression(ast.BinaryBitwiseXor, $0, $2, false) >>
    | Expression6
    ;

/* Bitwise AND operator */
Expression6:
      Expression6 "&" Expression5
      << ast.NewBinaryExpression(ast.BinaryBitwiseAnd, $0, $2, false) >>
    | Expression5
    ;

/* Bitwise left and right shift operators. */
Expression5:
      Expression5 ShiftOperator Expression4
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression4
    ;

/* Addition and subtraction operators */
Expression4:
      Expression4 AdditiveOperator Expression3
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3
    ;

/* Multiplication, division, and concatenation operators. */
Expression3:
      Expression3 MultiplicativeOperator Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression3 ConcatOp Expression2
      << ast.NewBinaryExpression($1, $0, $2, false) >>
    | Expression2
    ;

/* Unary operators */
Expression2:
      UnaryOperator Expression1
      << ast.NewUnaryExpression($0, $1) >>
    | Expression1
    ;

/* Field access operator, array subscript operator */
Expression1:
      NullLiteral
    | IntegerLiteral
    | BooleanLiteral
    | BytesLiteral
    | StringLiteral
    | FloatingPointLiteral
    | JSONLiteral
    | ParenthesizedExpression
    | ArrayConstructor
    | StructConstructor
    | CastExpression
    | FunctionCallExpressionWithClauses
    | Identifier
      << ast.NewPathExpression($0) >>
    | Expression1 "[" Expression1 "]"
      <<
      func() (Attrib, error) {
          e, err := ast.NewArrayElement($0, $2)
          if err != nil {
              return nil, err
          }

          return OverrideLoc(e, $1, $3)
      }()
      >>
    | Expression1 "." Identifier
      << ExpandPathExpressionOrNewDotIdentifier($0, $1, $2) >>
    ;

LikeOperator:
      like     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not like << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

InOperator:
      in      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not in  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

BetweenOperator:
      between     << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | not between << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

IsOperator:
      is      << WrapWithLoc(ast.NotKeywordAbsent, $0) >>
    | is not  << WrapWithLoc(ast.NotKeywordPresent, $0, $1) >>
    ;

UnaryOperator:
      "+"  << WrapWithLoc(ast.UnaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.UnaryMinus, $0) >>
    | "~"  << WrapWithLoc(ast.UnaryBitwiseNot, $0) >>
    ;

MultiplicativeOperator:
      "*"  << WrapWithLoc(ast.BinaryMultiply, $0) >>
    | "/"  << WrapWithLoc(ast.BinaryDivide, $0) >>
    ;

AdditiveOperator:
      "+"  << WrapWithLoc(ast.BinaryPlus, $0) >>
    | "-"  << WrapWithLoc(ast.BinaryMinus, $0) >>
    ;

ConcatOp:
      "||" << WrapWithLoc(ast.BinaryConcat, $0) >>
    ;

ShiftOperator:
      "<<"  << WrapWithLoc(ast.LeftShift, $0) >>
    | ">>"  << WrapWithLoc(ast.RightShift, $0) >>
    ;

IntegerLiteral:
      integer_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewIntLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

StringLiteral:
      string_literal
      << NewStringLiteral($0) >>
    ;

FloatingPointLiteral:
      floating_point_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewFloatLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

BytesLiteral:
      bytes_literal
      << NewBytesLiteral($0) >>
    ;

BooleanLiteral:
      boolean_literal
      <<
      func() (Attrib, error) {
          lit, err := ast.NewBooleanLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

NullLiteral:
      null
      <<
      func() (Attrib, error) {
          lit, err := ast.NewNullLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

JSONLiteral:
      json StringLiteral
      <<
      func() (Attrib, error) {
          lit, err := ast.NewJSONLiteral()
          if err != nil {
              return nil, err
          }

          return InitLiteral(lit, $0)
      }()
      >>
    ;

MaybeDashedPathExpression:
      PathExpression
    | DashedPathExpression
    ;

PathExpression:
      Identifier
      << ast.NewPathExpression($0) >>
    | PathExpression "." Identifier
      << WithExtraChild($0, $2) >>
    ;

DashedPathExpression:
      DashedIdentifier
    | DashedPathExpression "." Identifier
    ;

DashedIdentifier:
      identifier "-" identifier
      << NewDashedIdentifier($0, $1) >>
    ;

Identifier:
      identifier
      << NewIdentifier($0, true) >>
    | KeywordAsIdentifier
      << NewIdentifier($0, true) >>
    ;

KeywordAsIdentifier:
      date
    | numeric_or_decimal
    | extract
    | with
    | json
    ;

ParenthesizedExpression:
      "(" Expression ")"
      <<
      func() (Attrib, error) {
          e := $1.(ast.ExpressionHandler)
          e.SetParenthesized(true)

          // Do not include the location in the parentheses. Semantic
          // error messages about this expression should point at the
          // start of the expression, not at the opening parentheses.
          return WrapWithLoc(e, $0, $2)
      }()
      >>
    ;

OptSampleClause:
      SampleClause
    | empty
    ;

SampleClause:
      tablesample Identifier "(" SampleSize ")" OptSampleClauseSuffix
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleClause($1, $2, $3)
          if err != nil {
              return nil, err
          }

          UpdateLoc(s, $0)
          UpdateLoc(s, $4)

          return s, nil
      }()
      >>
    ;

SampleSize:
      SampleSizeValue SampleSizeUnit OptPartitionByClause
      << ast.NewSampleSize($0, $1, $2) >>
    ;

SampleSizeValue:
      PossiblyCastIntLiteralOrParameter
    | FloatingPointLiteral
    ;

SampleSizeUnit:
      rows     << WrapWithLoc(ast.RowsSampling, $0) >>
    | percent  << WrapWithLoc(ast.PercentSampling, $0) >>
    ;

OptSampleClauseSuffix:
      RepeatableClause
      << ast.NewSampleSuffix(nil, $0) >>
    | with weight OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix(nil, $2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | with weight Alias OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix($2, $3)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | with weight as Alias OptRepeatableClause
      <<
      func() (Attrib, error) {
          s, err := ast.NewSampleSuffix($3, $4)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(s, $0)
      }()
      >>
    | empty
    ;

OptRepeatableClause:
      RepeatableClause
    | empty
    ;

RepeatableClause:
      repeatable "(" PossiblyCastIntLiteralOrParameter ")"
      <<
      func() (Attrib, error) {
          c, err := ast.NewRepeatableClause($2)
          if err != nil {
              return nil, err
          }

          UpdateLoc(c, $0, $3)
          return c, nil
      }()
      >>
    ;

PossiblyCastIntLiteralOrParameter:
      CastIntLiteralOrParameter
    | IntLiteralOrParameter
    ;

CastIntLiteralOrParameter:
      cast "(" IntLiteralOrParameter as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, false)
          if err != nil {
              return nil, err
          }

          UpdateLoc(e, $0, $6)
          return e, nil
      }()
      >>
    ;

IntLiteralOrParameter:
      IntegerLiteral
    | ParameterExpression
    ;

ParameterExpression:
      NamedParameterExpression
    ;

NamedParameterExpression:
      "@" Identifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewParameterExpr($0)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | "@" KeywordAsIdentifier
      <<
      func() (Attrib, error) {
          e, err := ast.NewParameterExpr($0)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    ;

OptFormat:
      format Expression OptAtTimeZone
      <<
      func() (Attrib, error) {
          f, err := ast.NewFormatClause($1, $2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(f, $0)
      }()
      >>
    | empty
    ;

OptAtTimeZone:
      at time zone Expression << $3, nil >>
    | empty
    ;

OptPartitionByClause:
      PartitionByClause
    | empty
    ;

PartitionByClause:
      PartitionByClausePrefix
    ;

PartitionByClausePrefix:
      partition by Expression
      <<
      func() (Attrib, error) {
          c, err := ast.NewPartitionBy($2)
          if err != nil { return nil, err }
          return UpdateLoc(c, $0)
      }()
      >>
    | PartitionByClausePrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

OptTypeParameters:
      TypeParametersPrefix ")"
      << UpdateLoc($0, $1) >>
    | empty
    ;

TypeParametersPrefix:
      "(" TypeParameter
      <<
      func() (Attrib, error) {
          e, err := ast.NewTypeParameterList($1)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(e, $0)
      }()
      >>
    | TypeParametersPrefix "," TypeParameter
      << WithExtraChild($0, $2) >>
    ;

TypeParameter:
      IntegerLiteral
    | BooleanLiteral
    | StringLiteral
    | BytesLiteral
    | FloatingPointLiteral
    ;

OptOnOrUsingClauseList:
      OnOrUsingClause
      << ast.NewOnOrUsingClauseList($0) >>
    | OptOnOrUsingClauseList OnOrUsingClause
      << WithExtraChild($0, $1) >>
    ;

OnOrUsingClause:
      OnClause
    | UsingClause
    ;

OnClause:
      on Expression << $1, nil >>
    ;

UsingClause:
      UsingClausePrefix ")"
    ;

UsingClausePrefix:
      using "(" Identifier
      <<
      func() (Attrib, error) {
          c, err := ast.NewUsingClause($2)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $0)
      }()
      >>
    | UsingClausePrefix "," Identifier
      << WithExtraChild($0, $2) >>
    ;

JoinType:
      cross           << WrapWithLoc(ast.CrossJoin, $0) >>
    | full OptOuter   << WrapWithLoc(ast.FullJoin, $0, $1) >>
    | inner           << WrapWithLoc(ast.InnerJoin, $0) >>
    | left OptOuter   << WrapWithLoc(ast.LeftJoin, $0, $1) >>
    | right OptOuter  << WrapWithLoc(ast.RightJoin, $0, $1) >>
    | empty OptOuter  << WrapWithLoc(ast.DefaultJoin, $0, $1) >>
    ;

OptOuter:
      outer
    | empty
    ;

FunctionCallExpressionWithClauses:
      FunctionCallExpression OptOverClause
      <<
      func() (Attrib, error) {
          if $1 != nil {
              return ast.NewAnalyticFunctionCall($0, $1)
          }

          return $0, nil
      }()
      >>
    ;

FunctionCallExpression:
      /* Empty argument list */
      FunctionCallExpressionBase
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      <<
      func() (Attrib, error) {
          f := $0.(*ast.FunctionCall)

          if $1 != nil {
              err := f.InitOrderBy($1)
              if err != nil {
                  return nil, err
              }
          }

          if $2 != nil {
              err := f.InitLimitOffset($2)
              if err != nil {
                  return nil, err
              }
          }

          return UpdateLoc(f, $3)
      }()
      >>
      /* Non-empty argument list. */
    | FunctionCallExpressionWithArgsPrefix
      OptNullHandlingModifier
      OptOrderByClause
      OptLimitOffsetClause
      ")"
      <<
      func() (Attrib, error) {
          f := $0.(*ast.FunctionCall)

          if $1 != nil {
              err := f.InitNullHandlingModifier($1)
              if err != nil {
                  return nil, err
              }
          }

          if $2 != nil {
              err := f.InitOrderBy($2)
              if err != nil {
                  return nil, err
              }
          }

          if $3 != nil {
              err := f.InitLimitOffset($3)
              if err != nil {
                  return nil, err
              }
          }

          return UpdateLoc(f, $4)
      }()
      >>
    ;

FunctionCallExpressionWithArgsPrefix:
      FunctionCallExpressionBase FunctionCallArgument
      << WithExtraChild($0, $1) >>
    | FunctionCallExpressionBase "*"
      <<
      func() (Attrib, error) {
          s, err := ast.NewStar()
          if err != nil {
              return nil, err
          }

          s.SetImage("*")

          l, err := UpdateLoc(s, $1)
          if err != nil {
              return nil, err
          }

          return WithExtraChild($0, l)
      }()
      >>
    | FunctionCallExpressionWithArgsPrefix "," FunctionCallArgument
      << WithExtraChild($0, $2) >>
    ;

FunctionCallExpressionBase:
      PathExpression "(" distinct
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, true)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $2)
      }()
      >>
    | PathExpression "("
      <<
      func() (Attrib, error) {
          c, err := ast.NewFunctionCall($0, false)
          if err != nil {
              return nil, err
          }

          return UpdateLoc(c, $1)
      }()
      >>
    ;

FunctionCallArgument:
      Expression
    ;

OptNullHandlingModifier:
      ignore nulls
      << WrapWithLoc(ast.IgnoreNulls, $0, $1) >>
    | respect nulls
      << WrapWithLoc(ast.RespectNulls, $0, $1) >>
    | empty
      << ast.DefaultNullHandling, nil >>
    ;

OptOverClause:
      OverClause
    | empty
    ;

OverClause:
      over WindowSpecification
      << UpdateLoc($1, $0) >>
    ;

CastExpression:
      cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, false)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(e, $0, $6)
      }()
      >>
    | safe_cast "(" Expression as Type OptFormat ")"
      <<
      func() (Attrib, error) {
          e, err := ast.NewCastExpression($2, $4, $5, true)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(e, $0, $6)
      }()
      >>
    ;

ArrayConstructor:
      ArrayConstructorPrefixNoExpressions "]"
      << UpdateLoc($0, $1) >>
    | ArrayConstructorPrefix "]"
      << UpdateLoc($0, $1) >>
    ;

ArrayConstructorPrefixNoExpressions:
      array "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $0, $1)
      }()
      >>
    | "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $0)
      }()
      >>
    | ArrayType "["
      <<
      func() (Attrib, error) {
          c, err := ast.NewArrayConstructor($0)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(c, $1)
      }()
      >>
    ;

ArrayConstructorPrefix:
      ArrayConstructorPrefixNoExpressions Expression
      << WithExtraChild($0, $1) >>
    | ArrayConstructorPrefix "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructor:
      StructConstructorPrefix ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithKeywordNoArg ")"
      << UpdateLoc($0, $1) >>
    | StructConstructorPrefixWithoutKeyword ")"
      << UpdateLoc($0, $1) >>
    ;

StructConstructorPrefix:
      StructConstructorPrefixWithKeyword
    | StructConstructorPrefixWithKeywordNoArg
    | StructConstructorPrefixWithoutKeyword
    ;

StructConstructorPrefixWithKeyword:
      StructConstructorPrefixWithKeywordNoArg StructConstructorArg
    ;

StructConstructorPrefixWithKeywordNoArg:
      StructType "("
      << ast.NewStructConstructorWithKeyword($0) >>
    | struct "("
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithKeyword(nil)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    ;

StructConstructorPrefixWithoutKeyword:
      "(" Expression "," Expression
      <<
      func() (Attrib, error) {
          t, err := ast.NewStructConstructorWithParens(List($1, $3))
          if err != nil {
              return nil, err
          }
          return UpdateLoc(t, $0)
      }()
      >>
    | StructConstructorPrefixWithoutKeyword "," Expression
      << WithExtraChild($0, $2) >>
    ;

StructConstructorArg:
      Expression OptAsAliasWithRequiredAs
      << ast.NewStructConstructorArg($0, $1) >>
    ;

OptAsAliasWithRequiredAs:
      as Identifier
      <<
      func() (Attrib, error) {
          a, err := ast.NewAlias($1)
          if err != nil {
              return nil, err
          }
          return UpdateLoc(a, $0)
      }()
      >>
    | empty
    ;

ComparativeOperator:
      "="   << WrapWithLoc(ast.BinaryEq, $0) >>
    | "!="  << WrapWithLoc(ast.BinaryNE, $0) >>
    | "<>"  << WrapWithLoc(ast.BinaryNE2, $0) >>
    | "<"   << WrapWithLoc(ast.BinaryLT, $0) >>
    | "<="  << WrapWithLoc(ast.BinaryLE, $0) >>
    | ">"   << WrapWithLoc(ast.BinaryGT, $0) >>
    | ">="  << WrapWithLoc(ast.BinaryGE, $0) >>
    ;
